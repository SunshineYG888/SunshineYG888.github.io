{"meta":{"title":"Sunshine","subtitle":"Love life, as fanaticism as I love my yueqing.","description":"Hi, 我是杨刚,这里主要是记录和分享一些关于iOS开发和算法的东西.","author":"Gang Yang","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Objective-C Runtime","slug":"Objective-C-Runtime","date":"2016-05-24T10:27:20.000Z","updated":"2016-05-25T00:23:24.000Z","comments":true,"path":"2016/05/24/Objective-C-Runtime/","link":"","permalink":"http://yoursite.com/2016/05/24/Objective-C-Runtime/","excerpt":"本文整理了下 Objective-C Runtime 中的一些关键理论和一些应用实践，包括以下几部分：","text":"本文整理了下 Objective-C Runtime 中的一些关键理论和一些应用实践，包括以下几部分： 一、简介1、C + Runtime = Obj-C Objective-C 是一门动态语言，它将很多可以在编译连接的工作推迟到了运行时才做，所以它不仅需要编译器来编译代码，还得需要一个运行时系统( runtime system )来执行编译后的代码。所以这个运行时系统对 Objective-C 来说就像是操作系统，有了它 Objective-C 才能正常运作。Objective-C Runtime 是一个 Runtime 库，主要是用 C 和汇编写的，这个库让基于 C 的 Objective-C 有了面向对象的能力。可以在 这里 下载到 Runtime 的源码。 2、与 Runtime 交互 我们在使用 Objective-C 的过程中都无时无刻不在通过以下三种方法与 Runtime 系统进行交互： （1）使用 Objective-C 的源代码 我们在写 Objective-C 代码的时候，其实 Runtime 系统就自动地默默在幕后工作着。如在编译 Objective-C 中类和方法时，编译器都是将其转换为数据结构和函数。 （2）使用 NSObject 的方法 Cocoa 中大多数的类都继承自 NSObject 类，也就继承了它的方法。NSObject 的有些方法纯粹是用来获取 Runtime 系统的信息的，那些方法让对象拥有自省的能力。如： class 方法是返回某个对象所属的类；isKindOfClass: 和 isMemberOfClass: 是检查对象是否在某个继承体系中；respondsToSelector: 是检查对象是否能接受并响应某个信息；conformToProtocol: 是检查对象是否遵守了某个协议；methodForSelector: 是返回某个方法的具体实现的地址。 （3）使用 Runtime 函数 Runtime 是一个由一系列函数和数据结构组成的动态共享库( dynamic shared library )，并提供了一些公开的接口。所以我们也可以用纯 C 的代码来实现编译器编译 OC 代码后的效果。虽然大多数函数我们一般都是用不上的，但有时在某些情景下使用还是很有帮助的。 二、相关术语当在 OC 中使用方法 是这样的： 1[self doSomething]; 实际上会被转化为调用 objc_msgSend 函数，给某个对象发送消息： 1objc_msgSend(self, @selector(doSomething)); 它的声明是这样的： 1&#x2F;&#x2F; message.h2id objc_msgSend(id self, SEL op, ...); 那具体是怎样转换的？OC 中的类、方法、属性等在 C 语言中是怎样被表示的？下面先看下一些相关术语。 1、SEL SEL 是转换后的函数中第二个参数的类型，它的对象 selector (方法选择器) ，顾名思义，是用来识别和选择要执行的 OC 方法的。它的定义如下： 1&#x2F;&#x2F; objc.h2typedef struct objc_selector *SEL; 其实它就是个映射到方法的 C 字符串，上面就是通过 @selector(doSomething) 来获取一个名字叫 doSomething 的 selector。 2、id id 是转换后的函数中第一个参数的类型，它在 OC 中被称为万能指针，可以指向任何类的实例。它的定义如下： 1&#x2F;&#x2F; objc.h2typedef struct objc_object *id;3struct objc_object &#123;4 Class isa;5&#125;; objc_object 结构体中的第一个元素是 isa 指针，根据它可以找到对象所属的类。（但要注意在 KVO 中 isa 指针指向的是一个中间类了） 3、Class 上面说的 isa 的类型是 Class，而它的定义如下： 1&#x2F;&#x2F; objc.h2typedef struct objc_class *Class;34&#x2F;&#x2F; runtime.h5struct objc_class &#123;6 Class isa;78 Class super_class;9 const char *name;10 long version;11 long info;12 long instance_size;13 struct objc_ivar_list *ivars;14 struct objc_method_list **methodLists;15 struct objc_cache *cache;16 struct objc_protocol_list *protocols;17&#125;; 可见在 Runtime 系统中，一个类还关联了它的父类指针、类名、成员变量、方法、缓存、协议。注意到不仅表示对象的 objc_object 结构体中有个 isa 指针，表示类的 objc_class 结构体中也有个 isa 指针，这是因为在 OC 中，类本身也是一个对象（类对象）。对象的方法存储在它所属的类中，那类的方法呢？这时就需要类对象所属的类来存储类方法了，它叫 meta class(元类)。对象的类、父类、元类之间的关系如下（实现是 super_class 指针，虚线是 isa 指针）： 注意到所有的元类的元类都是 root class（meta），而这个根元类的元类是它自己，它的父类是 NSObject；NSObject 的元类也是那个根元类，但它没有父类。 4、成员变量 其中 objc_ivar_list 是成员变量列表，定义如下： 1&#x2F;&#x2F; runtime.h2struct objc_ivar_list &#123;3 int ivar_count;4 int space;5 struct objc_ivar ivar_list[1];6&#125;7struct objc_ivar &#123;8 char *ivar_name;9 char *ivar_type;10 int ivar_offset;11 int space;12&#125; 13typedef struct objc_ivar *Ivar; 可见成员变量列表 objc_ivar_list 结构体存储着由成员变量 objc_ivar 结构体组成的数组，objc_ivar 结构体存储着单个成员变量的名字、类型、偏移量等信息。 5、方法 objc_method_list 是方法列表，定义如下： 1&#x2F;&#x2F; runtime.h2struct objc_method_list &#123;3 struct objc_method_list *obsolete;4 int method_count;5 int space;6 struct objc_method method_list[1];7&#125; 8struct objc_method &#123;9 SEL method_name;10 char *method_types;11 IMP method_imp;12&#125; 13typedef struct objc_method *Method; 可见方法列表 objc_method_list 结构体存储着由方法 objc_method 结构体组成的数组，objc_method 结构体存储着单个方法的信息：名称(SEL类型的)、参数类型和返回值类型(method_types中)和具体实现(IMP类型的)。 6、IMP IMP(method implementation，方法实现) 的定义是： 1&#x2F;&#x2F; objc.h2typedef id (*IMP)(id, SEL, ...); 所以它其实是一个函数指针，指向某个方法的具体实现。它的类型和 objc_msgSend 函数相同，参数中也都包含有 id 和 SEL 类型，这是因为一个 id 和 一个 SEL 参数就能确定唯一的方法实现地址。 7、Cache 在 objc_class 结构体中还有个指向 objc_cache 结构体的指针，它的定义如下： 1&#x2F;&#x2F; runtime.h2typedef struct objc_cache *Cache3&#x2F;&#x2F; objc-cache.m4struct objc_cache &#123;5 &#x2F;&#x2F; 当前能达到的最大 index6 uintptr_t mask; 7 &#x2F;&#x2F; 被占用的槽位。因为缓存是以散列表的形式存在，所以会有空槽8 uintptr_t occupied; 9 &#x2F;&#x2F; 用数组表示的 hash 表10 cache_entry *buckets[1];11&#125;;12typedef struct &#123;13 SEL name; 14 void *unused;15 IMP imp; 16&#125; cache_entry;17&#x2F;&#x2F; _uintptr_t.h18typedef unsigned long uintptr_t; 所以它用来做缓存的，用 buckets 数组来存储被调用过的方法。因为一个方法被调用过，那它以后有可能还会被调用，所以将其存储起来，下次要找某方法先到缓存中找，如果找到的话，免去后面的寻找过程，速度虽然仍会比直接调用函数慢一点点，但已经有很大提升。 8、属性 还有我们常用的属性其实也是结构体，它的定义如下： 1&#x2F;&#x2F; runtime.h2typedef struct objc_property *objc_property_t;3typedef struct &#123;4 const char *name;5 const char *value;6&#125; objc_property_attribute_t;78&#x2F;&#x2F; objc-runtime-new.h9typedef struct objc_property &#123;10 const char *name;11 const char *attributes;12&#125; property_t;13typedef struct property_list_t &#123;14 uint32_t entsize;15 uint32_t count;16 property_t first;17&#125; property_list_t; 所以一个 property_t 结构包含了属性的名称和属性字符串。与属性相关的一些方法如下： 1#define newproperty(p) ((property_t *)p)2&#x2F;&#x2F; 返回协议中的属性列表，属性个数存储在参数 outCount 中3objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)4&#x2F;&#x2F; 返回类中的属性列表，属性个数存储在参数 outCount 中5objc_property_t *class_copyPropertyList(Class cls_gen, unsigned int *outCount)6&#x2F;&#x2F; 返回属性列表中的属性数组，属性个数存储在参数 outCount 中7static property_t **copyPropertyList(property_list_t *plist, unsigned int *outCount)8&#x2F;&#x2F; 返回类中的特定名字的属性9objc_property_t class_getProperty(Class cls_gen, const char *name)10&#x2F;&#x2F; 返回某个属性的名字11const char *property_getName(objc_property_t prop)12&#x2F;&#x2F; 返回某个属性的属性字符串13const char *property_getAttributes(objc_property_t prop) 三、objc_msgSend使用某对象的方法，都是给这个对象发送消息，消息和方法实现直到运行时才会绑定。Runtime 系统会把使用方法转换为调用函数： 1objc_msgSend(receiver, selector) 注意到此时函数多了两个参数：消息接收者、方法的 selector。这是每个方法调用时都会默认存在的隐藏参数。如果还有其他参数则是： 1objc_msgSend(receiver, selector, arg1, arg2, ...) objc_msgSend 要做的事件有三件：（1）找到 selector 对应的方法实现；（2）调用该方法实现，并把消息接收者（如果有参数则加上那些参数）传给它；（3）把方法实现的返回值传回去（它自己并没有任何返回值）。其中第（1）件事的最关键的，具体过程如下： （1）检查该 selector 是不是要忽略的；（2）检查这个 target 是否为 nil。在 OC 中给 nil 发送任何消息都不会出错，返回的结果都是 0 或 nil。（3）开始找这个类的 IMP。先在 cache 中找，找到则调到对应的方法实现中去执行。（4）在 cache 中没找到，则在该类的方法分发表(dispatch table，即方法列表)中找，找到则执行。（5）在该类的方法分发表中找不到，则到父类的分发表中找，再找不到则往上找，直到 NSObject 类为止。这两个过程的示意图如下： 如果找到，还会根据是否把消息传给父类、返回值是否数据结构而选择下面四个函数中的一个来调用： 1&#x2F;&#x2F; message.h2id objc_msgSend(id self, SEL op, ...)3id objc_msgSendSuper(struct objc_super *super, SEL op, ...)4void objc_msgSend_stret(id self, SEL op, ...)5void objc_msgSendSuper_stret(struct objc_super *super, SEL op, ...) 函数中的 super 关键字是指向 objc_super 结构体的指针，objc_super 结构体定义如下： 1struct objc_super &#123;2 &#x2F;&#x2F; receiver 仍是 self 本身3 __unsafe_unretained id receiver;4 &#x2F;&#x2F; 父类的类型5 __unsafe_unretained Class super_class;6&#125;; 要注意的是如果想获取某个类的父类，要用 cls-&gt;super_class 或 class_getSuperclass 方法，而不应该用 [super class]，因为 [super class] 会变为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，即获得的是 objc_super-&gt;receiver 的类，跟 [self class] 的结果是一样的。（6）动态方法解析（Dynamic Method Resolution）：如果该类及其继承体系的分发表都没找到，则开始动态方法解析，这是 Runtime 系统在报错前给我们的第一次补救的机会，它会调用 resolveInstanceMethod: 或者 resolveClassMethod: 方法，所以我们可以在这两方法中分别用 class_addMethod 给某个类或对象的某个 selector 动态添加一个方法实现。 如在 main 函数中调用 Person 对象的一个 aMethod 方法： 1 Person *p &#x3D; [[Person alloc] init];2 [p aMethod]; 它的 .h 和 .m 文件如下： 1&#x2F;&#x2F; Person.h2#import &lt;Foundation&#x2F;Foundation.h&gt;3@interface Person : NSObject4- (void)aMethod;5@end67&#x2F;&#x2F; Person.m8#import &quot;Person.h&quot;9#import &lt;objc&#x2F;runtime.h&gt;1011&#x2F;&#x2F; 要被动态添加的方法实现12void dynamicMethodIMP(id self, SEL _cmd) &#123;13 NSLog(@&quot;dynamicMethodIMP&quot;);14&#125;1516@implementation Person17&#x2F;&#x2F; 动态方法解析18+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;19 &#x2F;&#x2F; 如果是要被添加方法实现的 selector20 if (sel &#x3D;&#x3D; @selector(aMethod)) &#123;21 &#x2F;&#x2F; 给 self 的类的 sel 方法选择器动态添加方法实现 dynamicMethodIMP22 class_addMethod([self class], sel, (IMP)dynamicMethodIMP, &quot;v@:&quot;);23 &#x2F;&#x2F; 返回 YES 后， Runtime 重新给对象发送 aMethod 消息，这次就可以找到 dynamicMethodIMP 方法实现并调用它了24 return YES;25 &#125;26 return [super resolveInstanceMethod:sel];27&#125;2829@end （7）重定向：如果在上面的方法中不做处理或返回 NO，Runtime 系统在报错前还会给第二次补救机会，就是会调用 forwardingTargetForSelector: 方法索要一个能响应这个消息的对象，所以我们可以在这里返回另外一个能处理该消息的对象： 1&#x2F;&#x2F; Person.m2- (id)forwardingTargetForSelector:(SEL)aSelector &#123;3 &#x2F;&#x2F; 如果是要被添加方法实现的 selector4 if (aSelector &#x3D;&#x3D; @selector(aMethod)) &#123;5 &#x2F;&#x2F; 返回另外一个对象，让它去接收该消息6 return [[Car alloc] init];7 &#125;8 return [super forwardingTargetForSelector:aSelector];9&#125; 上面返回的是一个 Car 对象，如果 Car 类定义如下： 1&#x2F;&#x2F; Car.h2#import &lt;Foundation&#x2F;Foundation.h&gt;3@interface Car : NSObject4- (void)aMethod;5@end6&#x2F;&#x2F; Car.m7#import &quot;Car.h&quot;8@implementation Car9- (void)aMethod &#123;10 NSLog(@&quot;car aMethod&quot;);11&#125;12@end 则输出结果就是 “car aMethod”了。 （8）消息转发：如果在上一步中不做处理或者返回 nil 或 self，则 Runtime 系统会在报错前给我们最后一次补救机会。系统会先调用 methodSignatureForSelector: 方法，在该方法返回一个包含了消息的描述信息的方法签名（NSMethodSignature对象），并用此方法签名去生成一个 NSInvocation 对象，然后调用 forwardInvocation: 方法并把刚生成的 NSInvocation 对象作参数传进去。我们就可以重写 forwardInvocation: 方法，在这里将消息转发给其他对象： 1&#x2F;&#x2F; 获取一个方法签名，用于生成 NSInvocation 对象2- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;3 NSMethodSignature *signature &#x3D; [super methodSignatureForSelector:aSelector];4 if (!signature) &#123;5 signature &#x3D; [[Car new] methodSignatureForSelector:aSelector];6 &#125;7 return signature;8&#125;910- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;11 &#x2F;&#x2F; 如果另一个对象能响应该方法12 if ([[Car new] respondsToSelector:[anInvocation selector]]) &#123;13 &#x2F;&#x2F; 则让另一个对象来响应该方法14 [anInvocation invokeWithTarget:[Car new]];15 &#125; else &#123;16 [super forwardInvocation:anInvocation];17 &#125;18&#125; 尽管消息转发的效果类似于多继承，让一个对象看起来能处理自己不拥有的方法，但 NSObject 类不会将两者混淆。如上面的例子， [p respondsToSelector:@selector(aMethod)] 的结果还是 NO。 PS: 上面调用的方法顺序也可以这样获得：在程序启动之后暂停，然后在 gdb 中输入这个命令：call (void)instrumentObjcMessageSends(YES)，再运行，则发送的所有消息都会打印到 /tmp/msgSend-xxxx 文件里了。如新建一个 Teacher 类，给它的实例发送一条错误的消息： 1 Teacher *teacher &#x3D; [[Teacher alloc] init];2 [teacher aMehtod]; 则打印结果如下 四、应用上面讲的术语和响应消息可能还是比较抽象的，下面介绍下我们在项目中用得上的一些 Runtime API： 1、自定义 tabBar 大多 App 都是使用继承自 UITabBarController 的自定义控制器做 window 的 rootViewController，系统提供的 tabBar 可能满足不了我们的需求，此时我们可以通过以下方法使用我们自定义的 tabBar 并布局其中的按钮： 1&#x2F;&#x2F; YGMainViewController.m2- (void)viewDidLoad &#123;3 [super viewDidLoad];4 &#x2F;&#x2F;创建并使用自定义的 tabBar5 YGMainTabBar *mainTarBar &#x3D; [YGMainTabBar new];6 [self setValue:mainTarBar forKey:@&quot;tabBar&quot;];7&#125;8&#x2F;&#x2F; YGMainTabBar.m9- (void)layoutSubviews &#123;10 [super layoutSubviews];11 for (UIView *subView in self.subviews) &#123;12 if ([subView isKindOfClass:NSClassFromString(@&quot;UITabBarButton&quot;)]) &#123;13 &#x2F;&#x2F; 布局按钮14 &#125;15 &#125;16&#125; 2、获取属性名 我们在用字典生成模型时一般是使用 - setValuesForKeysWithDictionary: 方法来赋值，并用 - setValue:forUndefinedKey: 方法来过滤掉多余的键值。我们也可以用 Runtime 提供的方法来获取某个类的共有属性名,再逐一使用 - setValue:forKey: 进行 KVC 赋值： 1&#x2F;&#x2F; 类方法：字典 --&gt; 模型, KVC2+ (instancetype)cycleWithDict:(NSDictionary *)dict&#123;3 id obj &#x3D; [[self alloc] init];4 5 for (NSString *key in [self publicProperties]) &#123;6 if (dict[key]) &#123;7 [obj setValue:dict[key] forKey:key];8 &#125;9 &#125;10 11 return obj;12&#125;1314&#x2F;&#x2F; 通过 runtime 方法获取所有公有属性名15+ (NSArray *)publicProperties&#123;16 unsigned int count &#x3D; 0;17 &#x2F;&#x2F; 获取当前类的属性列表（即数组）18 objc_property_t *propertyList &#x3D; class_copyPropertyList([self class], &amp;count);19 20 NSMutableArray *ocProperties &#x3D; [NSMutableArray array];21 for (int i &#x3D; 0; i &lt; count; i++) &#123;22 &#x2F;&#x2F; 取出每一个属性23 objc_property_t property &#x3D; propertyList[i];24 &#x2F;&#x2F; 取出属性名25 const char *cPropertyName &#x3D; property_getName(property);26 &#x2F;&#x2F; C --&gt; OC27 NSString *ocPropertyName &#x3D; [[NSString alloc] initWithCString:cPropertyName28 encoding:NSUTF8StringEncoding];29 30 [ocProperties addObject:ocPropertyName];31 &#125;32 33 &#x2F;&#x2F; 释放34 free(propertyList);35 36 return ocProperties.copy;37&#125; 3、关联属性 我们还可能希望给某些常用的类添加 category，但 category 是只能添加方法而不能添加存储属性的。现在我们可以用 Runtime 来间接在 category 添加属性了，如在给 UIButton 的 category 中添加一个属性作回调： 1&#x2F;&#x2F; UIButton+Extension.h2#import &lt;UIKit&#x2F;UIKit.h&gt;3typedef void (^CallbackBlock)();4@interface UIButton (Extension)5@property (copy, nonatomic) CallbackBlock callback;6@end78&#x2F;&#x2F; UIButton+Extension.m9#import &quot;UIButton+Extension.h&quot;10#import &lt;objc&#x2F;runtime.h&gt;11const void *yg_callbackKey &#x3D; @&quot;yg_callbackKey&quot;;12@implementation UIButton (Extension)1314- (void)setCallback:(CallbackBlock)callback &#123;15 &#x2F;&#x2F; 设置关联属性16 objc_setAssociatedObject(self, yg_callbackKey, callback, OBJC_ASSOCIATION_COPY_NONATOMIC);17&#125;18- (CallbackBlock)callback &#123;19 &#x2F;&#x2F; 获取关联属性20 return objc_getAssociatedObject(self, yg_callbackKey);21&#125;2223@end 这样就可以把 callback 当做按钮的属性来用了: 1&#x2F;&#x2F; ViewController.m2#import &quot;ViewController.h&quot;3#import &quot;UIButton+Extension.h&quot;45@interface ViewController ()6@property (weak, nonatomic) IBOutlet UIButton *button;7@end89@implementation ViewController1011- (void)viewDidLoad &#123;12 [super viewDidLoad];1314 &#x2F;&#x2F; 设置按钮的 callback “属性”的内容15 self.button.callback &#x3D; ^&#123;16 NSLog(@&quot;button callback&quot;);17 &#125;;18 &#x2F;&#x2F; 获取并执行按钮的 callback “属性”19 self.button.callback();20&#125;2122@end 我们常用的第三方库中有很多也是这样用的，如 SDWebImage 会用这样的方法来存储传进来的图片的 URL： 1&#x2F;&#x2F; UIImageView+WebCache.m2- (void)sd_setImageWithURL:(NSURL *)url3 placeholderImage:(UIImage *)placeholder4 options:(SDWebImageOptions)options5 progress:(SDWebImageDownloaderProgressBlock)progressBlock6 completed:(SDWebImageCompletionBlock)completedBlock &#123;7 [self sd_cancelCurrentImageLoad];8 objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);9 ...10&#125;11- (NSURL *)sd_imageURL &#123;12 return objc_getAssociatedObject(self, &amp;imageURLKey);13&#125; 4、Method Swizzling 这个 Objective-C 中的“黑科技”，具体见 我之前的文章 本文用到的例子可见 我的Demo 参考： Runtime 源代码 Objective-C Runtime Programming Guide Understanding the Objective-C Runtime Objective-C Runtime Video Tutorial: Objective-C Runtime Objective-C 格致余论 1 - Selector objc_msgSend() Tour Part 1: The Road Map 深入理解Objective-C：方法缓存 iOS - NSInvocation的使用","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}]},{"title":"RunLoop 详解","slug":"RunLoop-详解","date":"2016-05-21T13:10:06.000Z","updated":"2016-05-21T22:02:53.000Z","comments":true,"path":"2016/05/21/RunLoop-详解/","link":"","permalink":"http://yoursite.com/2016/05/21/RunLoop-%E8%AF%A6%E8%A7%A3/","excerpt":"RunLoop 是 iOS 和 OSX 开发中非常重要的一个概念，本文主要从以下几部分介绍 RunLoop：","text":"RunLoop 是 iOS 和 OSX 开发中非常重要的一个概念，本文主要从以下几部分介绍 RunLoop： 本文用到的一些例子可见 我的Demo 一、基本概念1、RunLoop从字面上来看，RunLoop 是个运行循环。而官方文档对 RunLoop 的介绍是： Run loops are part of the fundamental infrastructure associated with threads. A run loop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events. The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none. 即 RunLoop 是与线程相关的事件处理循环，我们可以在这里安排操作和协调对从外面传进来的事件的接收。RunLoop 的目的是让我们的线程在有活干的时候工作，在没活干的时候进入睡眠。所以 RunLoop 能让程序保持活着，在没有消息可处理时休眠来节省 CPU 资源。这种机制也不是 iOS / OSX 特有。 如果没有 RunLoop，我们的程序是这样在一条线程中从上之下执行一次就退出的： 1int someFunc() &#123;2 &#x2F;&#x2F; do something3 return 0;4&#125; 而在 RunLoop 中，要保持线程总是活着，能不断的处于“接受消息 –&gt; 等待 –&gt; 处理消息”的循环中，则大致逻辑如下： 1int runloop() &#123;2 do &#123;3 receive_message();4 wait();5 process_message();6 &#125; while (!quit);7 return 0;8&#125; 在 Xcode 的项目中，main 函数中调用的 UIApplicationMain 函数内部就启动了一个 RunLoop，保持程序的持续运行，而且这个默认启动的 RunLoop 的与主线程相关联的： 1int main(int argc, char * argv[]) &#123;2 @autoreleasepool &#123;3 return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));4 &#125;5&#125; 也因为 UIApplicationMain 一直在运行，没有返回，所以如果把 main 函数改为下面这样，则 UIApplicationMain 函数之后的代码在程序运行阶段都是不会执行的： 1int main(int argc, char * argv[]) &#123;2 @autoreleasepool &#123;3 int result &#x3D; UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));4 &#x2F;&#x2F; 只要程序在运行，不会运行到下面这句5 NSLog(@&quot;after UIApplicationMain&quot;);6 return result;7 &#125;8&#125; 在 iOS 中，RunLoop 就是个对象，在 CoreFoundation 框架为 CFRunLoopRef 对象，它提供了纯 C 函数的 API，并且这些 API 是线程安全的；而在 Foundation 框架中用 NSRunLoop 对象来表示，它是基于 CFRunLoopRef 的封装，提供的是面向对象的 API，但这些 API 不是线程安全的。CFRunLoopRef 的代码是开源的，我们可以在 这里 或 这里 找到 CFRunLoop.c 来查看 RunLoop 的源码。 2、构成元素在 CoreFoundation 中关于 RunLoop 有 5 个类： CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 这 5 个类都在 CFRunLoop.c 中都有定义，除 CFRunLoopModeRef 外都在 CFRunLoop.h 公开： 1&#x2F;&#x2F; CFRunLoop.h2typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;3typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopSource * CFRunLoopSourceRef;4typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopObserver * CFRunLoopObserverRef;5typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef;67&#x2F;&#x2F; CFRunLoop.c8struct __CFRunLoop &#123;9 pthread_t _pthread;10 CFMutableSetRef _commonModes;11 CFRunLoopModeRef _currentMode;12 ...13&#125;;1415struct __CFRunLoopMode &#123;16 CFMutableSetRef _sources0;17 CFMutableSetRef _sources1;18 CFMutableArrayRef _observers;19 CFMutableArrayRef _timers;20 ...21&#125;; 所以一个 RunLoop 对应一条线程，可以包含若干个 mode，但一个时刻只能在一个 mode 上运行（即 currentMode），要切换 mode 只能退出 loop 再指定一个 mode 后重新进入。每个 mode 可以包含若干个 source/timer/observer，不同组之间的互不影响。这 5 个类的关系大致如下： CFRunLoopModeRef 官方文档介绍如下： A run loop mode is a collection of input sources and timers to be monitored and a collection of run loop observers to be notified.You must be sure to add one or more input sources, timers, or run-loop observers to any modes you create for them to be useful.You use modes to filter out events from unwanted sources during a particular pass through your run loop. 即一个 run loop mode 是若干个 source、timer 和 observer 的集合，它能帮我们过滤掉一些不想要的事件。即一个 RunLoop 在某个 mode 下运行时，不会接收和处理其他 mode 的事件 。要保持一个 mode 活着，就必须往里面添加至少一个 source、timer 或 observer 。 苹果公开的 mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode。前者是默认的模式，程序运行的大多时候都处于该 mode 下，后者是滑动 tableView 等时为了界面流畅而用的 mode。还有个 UIInitializationRunLoopMode 是程序启动时进入的 mode，一般用不上。 CFRunLoop 还定义了一个伪 mode 叫 kCFRunLoopCommonModes，它不是一个真正的 mode，而是若干个 mode 的集合，加到 CommonMode 的 source/timer/observer 相当于添加到了它里面所有的 mode 中。我们可以通过 NSLog(@&quot;%@&quot;, [NSRunLoop currentRunLoop]) 从打印结果看到 CommonMode 包含了上面的 DefaultMode 和 TrackingRunLoopMode： 1common modes &#x3D; &lt;CFBasicHash 0x7fdaa0d00ae0 [0x1084b57b0]&gt;&#123;type &#x3D; mutable set, count &#x3D; 2,2entries &#x3D;&gt;30 : &lt;CFString 0x10939f950 [0x1084b57b0]&gt;&#123;contents &#x3D; &quot;UITrackingRunLoopMode&quot;&#125;42 : &lt;CFString 0x1084d5b40 [0x1084b57b0]&gt;&#123;contents &#x3D; &quot;kCFRunLoopDefaultMode&quot;&#125;5&#125; 因为 mode 类没有公开，所以是通过 CFStringRef 字符串来操作。 如要查看程序什么时候处于哪个 mode，我们可以新建一个 project，在界面上添加一个 textField，然后 ViewController.m 代码如下： 1@interface ViewController () &lt;UITextViewDelegate&gt;2@property (weak, nonatomic) IBOutlet UITextView *textFeild;3@end45@implementation ViewController6- (void)viewDidLoad &#123;7 [super viewDidLoad];8 self.textFeild.delegate &#x3D; self;9 NSLog(@&quot;viewDidLoad: %@&quot;, [NSRunLoop currentRunLoop].currentMode);10&#125;1112- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;13 NSLog(@&quot;touch: %@&quot;, [NSRunLoop currentRunLoop].currentMode);14&#125;1516#pragma mark - UITextViewDelegate17- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;18 NSLog(@&quot;scrollViewDidScroll: %@&quot;, [NSRunLoop currentRunLoop].currentMode);19&#125;20@end 运行后，先后点击屏幕、拖拽 textField，打印如下： 12016-05-20 23:51:33.869 RunLoopTest[3317:206736] viewDidLoad: UIInitializationRunLoopMode22016-05-20 23:51:38.636 RunLoopTest[3317:206736] touch: kCFRunLoopDefaultMode32016-05-20 23:51:40.709 RunLoopTest[3317:206736] scrollViewDidScroll: kCFRunLoopDefaultMode42016-05-20 23:51:40.732 RunLoopTest[3317:206736] scrollViewDidScroll: UITrackingRunLoopMode52016-05-20 23:51:40.754 RunLoopTest[3317:206736] scrollViewDidScroll: UITrackingRunLoopMode6... 所以在 viewDidLoad 时是处于 UIInitializationRunLoopMode，之后程序大部分时间处于 kCFRunLoopDefaultMode，当滑动 scrollView 时会将切换到 UITrackingRunLoopMode。一个经典的问题是：当我们用 [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(run) userInfo:nil repeats:YES] 添加一个 timer 到主线程时，默认是添加到 DefaultMode 上，刚开始时 timer 可以正常工作并调用 [self run] 方法，但若此时滑动了 textView ，RunLoop 就切换到了 UITrackingRunLoopMode，这样处于另外一个 mode(DefaultMode) 的这个 timer 就会失效，使之不影响到滑动效果。如果我们希望 timer 在滑动 textView 的时候仍能正常工作，则需要用下面的做法把 timer 加进 CommonMode 中，这样就可以在 DefaultMode 或 TrackingRunLoopMode 下都能工作了。 CFRunLoopSourceRef source 是事件产生的地方（输入源），虽然官方文档在概念上把 source 分为三类：Port-Based Sources，Custom Input Sources，Cocoa Perform Selector Sources。 但在源码中 source 只有两个版本：source0 和 source1，它们的区别在于它们是怎么被标记 (signal) 的。 source0 是 app 内部的消息机制，使用时需要调用 CFRunLoopSourceSignal()来把这个 source 标记为待处理，然后掉用 CFRunLoopWakeUp() 来唤醒 RunLoop，让其处理这个事件。 1void CFRunLoopSourceSignal(CFRunLoopSourceRef rls) &#123;2 if (__CFIsValid(rls)) &#123;3 __CFRunLoopSourceSetSignaled(rls);4 &#125;5&#125;6void CFRunLoopWakeUp(CFRunLoopRef rl) &#123;7 if (__CFRunLoopIsIgnoringWakeUps(rl)) &#123;8 return;9 &#125;10 SetEvent(rl-&gt;_wakeUpPort);11&#125; 用上面的 project，在 touchesBegan... 方法中打断点，点击屏幕可以看到调用栈是这样的： 注意到 RunLoop 是在 CFRunLoopRun 函数(下面再介绍)中调用了 __CFRunLoopDoSources0() 来处理 source0，它的过程简化如下： 1static Boolean __CFRunLoopDoSources0(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) &#123;2 Boolean sourceHandled &#x3D; false;3 &#x2F;&#x2F; 判断 source 是否为空4 if (NULL !&#x3D; sources) &#123;5 &#x2F;&#x2F; 判断 source 是否被标记6 if (__CFRunLoopSourceIsSignaled(rls)) &#123;7 &#x2F;&#x2F; 取消标记8 __CFRunLoopSourceUnsetSignaled(rls);9 &#x2F;&#x2F; 判断 source 是否有效10 if (__CFIsValid(rls)) &#123;11 &#x2F;&#x2F; 处理 source12 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(...);13 sourceHandled &#x3D; true;14 &#125;15 return sourceHandled;16&#125;1718__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ 函数看起来很长，但其实也没干什么事，只是调用函数：1920static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(void (*perform)(void *), void *info) &#123;21 if (perform) &#123;22 perform(info);23 &#125;24&#125; 其他类似的还有下面几个，它们都只是帮助我们在调用栈上调试，确保所有的代码调用都从这几种函数中的某一个开始的： static void CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION();static void CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK();static void CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE();static void CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION();static void CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION(); source1 是基于 mach_ports 的，用于通过内核和其他线程互相发送消息。iOS / OSX 都是基于 Mach 内核，Mach 的对象间的通信是通过消息在两个端口(port)之间传递来完成。很多时候我们的 app 都是处于什么事都不干的状态，在空闲前指定用于唤醒的 mach port 端口，然后在空闲时被 mach_msg() 函数阻塞着并监听唤醒端口， mach_msg() 又会调用 mach_msg_trap() 函数从用户态切换到内核态，这样系统内核就将这个线程挂起，一直停留在 mac_msg_trap 状态。直到另一个线程向内核发送这个端口的 msg 后， trap 状态被唤醒， RunLoop 继续开始干活当程序在运行但又空闲的时候，我们可以暂停它，可以看到此时的调用栈是这样的： CFRunLoopTimerRef CFRunLoopTimerRef 基于时间的触发器，在 iOS 用到的 NSTimer 或者 performSelector:afterDelay: 都是通过它来实现的。使用时先设置一个时间长度和一个回调，然后将其加入 RunLoop，这样 RunLoop 就会注册对应的时间点，当到了该时间点时就会唤醒 RunLoop 来执行那个回调。iOS7 之后，timer 还可有一个 tolerance，因为 timer 不太准确，如上面提到的，某个 mode 下的 timer 在 RunLoop 切换 mode 时可能就失效了，而 tolerance 则用来计算最后能执行那个回调的时间点。 CFRunLoopObserverRef CFRunLoopObserverRef 是观察者，可以用来观测 RunLoop 的状态的变化。可以观测的情况有： 1&#x2F;* Run Loop Observer Activities *&#x2F;2typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;3 &#x2F;&#x2F; 即将进入 loop4 kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0),5 &#x2F;&#x2F; 即将处理 timer6 kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1),7 &#x2F;&#x2F; 即将处理 source8 kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2),9 &#x2F;&#x2F; 即将 sleep10 kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5),11 &#x2F;&#x2F; 刚被唤醒，退出 sleep12 kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6),13 &#x2F;&#x2F; 即将退出14 kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7),15 &#x2F;&#x2F; 全部的活动16 kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU17&#125;; 我们可以使用 CFRunLoopObserverCreateWithHandler() 来创建 observer，创建时设置要监听的状态变化和回调，再用 CFRunLoopAddObserver() 来给 RunLoop 添加 observer，当该 RunLoop 状态发生在监听类型内的变化时，observer 就会执行回调 ： 1 &#x2F;* 2 创建 observer：3 传入的参数：observer, 要监听 RunLoop 的哪些状态变化，是否重复，顺序，监听到状态变化的回调4 *&#x2F;5 CFRunLoopObserverRef observer &#x3D;6 CFRunLoopObserverCreateWithHandler(7 CFAllocatorGetDefault(),8 kCFRunLoopAllActivities,9 YES,10 0,11 ^(CFRunLoopObserverRef observer,12 CFRunLoopActivity activity) &#123;13 NSLog(@&quot;RunLoop 的状态变化：%zd&quot;, activity);14 &#125;);15 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);16 CFRelease(observer); 二、运行逻辑1、获取 RunLoop苹果不允许我们创建 RunLoop，要获取主线程或当前线程对应的 RunLoop，只能通过 CFRunLoopGetMain 或 CFRunLoopGetCurrent 函数，获取过程大致如下： 1&#x2F;&#x2F; 全局的 dictionary, key 是 pthread_t， value 是 CFRunLoopRef2static CFMutableDictionaryRef __CFRunLoops &#x3D; NULL;34CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;5 &#x2F;&#x2F; 第一次进入时，创建全局 dictionary6 if (!__CFRunLoops) &#123;7 &#x2F;&#x2F; 创建可变字典8 CFMutableDictionaryRef dict &#x3D; CFDictionaryCreateMutable();9 &#x2F;&#x2F; 先创建主线程的 RunLoop10 CFRunLoopRef mainLoop &#x3D; __CFRunLoopCreate(pthread_main_thread_np());11 &#x2F;&#x2F; 主线程的 RunLoop 存进字典中12 CFDictionarySetValue(dict, pthread_main_thread_np(), mainLoop);13 &#125;14 15 &#x2F;&#x2F; 用 传进来的线程 作 key，获取对应的 RunLoop16 CFRunLoopRef loop &#x3D; CFDictionaryGetValue(__CFRunLoops, t);17 18 &#x2F;&#x2F; 如果获取不到，则新建一个，并存入字典19 if (!loop) &#123;20 CFRunLoopRef newLoop &#x3D; __CFRunLoopCreate(t);21 CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);22 &#125;23 return loop;24&#125;2526&#x2F;&#x2F; 获取主线程的 RunLoop27CFRunLoopRef CFRunLoopGetMain(void) &#123;28 if (!__main) __main &#x3D; _CFRunLoopGet0(pthread_main_thread_np());29 return __main;30&#125;3132&#x2F;&#x2F; 获取当前线程的 RunLoop33CFRunLoopRef CFRunLoopGetCurrent(void) &#123;34 return _CFRunLoopGet0(pthread_self());35&#125; 可见，线程和 RunLoop 是一一对应的，对应关系保存在一个全局的 dictionary 中。RunLoop 类似懒加载，只有在第一次获取的时候才会创建。当线程销毁时，也销毁对应的 RunLoop。 2、RunLoop 的运行：1&#x2F;&#x2F; 用 DefaultMode 启动2void CFRunLoopRun(void) &#123; &#x2F;* DOES CALLOUT *&#x2F;3 CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);4&#125;56&#x2F;&#x2F; 用指定的 mode 启动7SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123; 8 return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);9&#125;1011&#x2F;&#x2F; RunLoop 的实现12SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123; 13 &#x2F;&#x2F; 根据 modeName 找到对应的 mode14 CFRunLoopModeRef currentMode &#x3D; __CFRunLoopFindMode(rl, modeName, false);15 &#x2F;&#x2F; 判断 mode 是否为空 (即 source&#x2F;timer 皆空)，是的话则返回16 if (NULL &#x3D;&#x3D; currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;17 return ;18 &#125;19 &#x2F;&#x2F; 通知 observers: 即将进入 loop20 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);21 &#x2F;&#x2F; 进入 loop22 result &#x3D; __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);23 &#x2F;&#x2F; 通知 observers： 即将退出24 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);2526 return;27&#125; 1&#x2F;&#x2F; 进入 RunLoop 后2static int32_t __CFRunLoopRun() &#123;3 &#x2F;&#x2F; 设置 timer4 dispatch_source_t timeout_timer &#x3D; NULL;5 &#x2F;&#x2F; 设置过期时间6 seconds &#x3D; 9999999999.0;78 int32_t retVal &#x3D; 0;9 10 &#x2F;&#x2F; 开始 loop11 do &#123;12 &#x2F;&#x2F; 告诉 observer：要处理 timer13 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);14 &#x2F;&#x2F; 告诉 observer：要处理 sources15 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);16 17 &#x2F;&#x2F; 执行被加入的 block18 __CFRunLoopDoBlocks(rl, rlm);19 20 &#x2F;&#x2F; 处理 Sources0（非 port）21 Boolean sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);22 if (sourceHandledThisLoop) &#123;23 __CFRunLoopDoBlocks(rl, rlm);24 &#125;2526 if (!didDispatchPortLastTime) &#123;27 &#x2F;&#x2F; 如果有 GCD 分发到 main queue 的 block28 if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg)) &#123;29 &#x2F;&#x2F; 跳过睡眠阶段，直接去处理消息30 goto handle_msg;31 &#125;32 &#125;3334 &#x2F;&#x2F; 通知 observers：即将进入睡眠35 if () __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);3637 &#x2F;&#x2F; 调用 mach_msg 等待接受 mach_port 的消息，线程将进入睡眠38 __CFRunLoopServiceMachPort(waitSet, &amp;msg, ...);39 40 &#x2F;&#x2F; 通知 observers：刚被唤醒41 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);42 43 &#x2F;&#x2F; 处理消息的标记44 handle_msg:;4546 &#x2F;&#x2F; 通过判断端口，找出要处理的事件47 if (MACH_PORT_NULL &#x3D;&#x3D; livePort) &#123;48 &#x2F;&#x2F; 纯粹是被手动唤醒的，无消息，则不做任何处理49 &#125; else if (livePort &#x3D;&#x3D; rlm-&gt;_timerPort) &#123;50 &#x2F;&#x2F; 被 timer 唤醒,则触发这个 timer 的回调51 __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())；52 &#125; else if (livePort &#x3D;&#x3D; dispatchPort) &#123;53 &#x2F;&#x2F; 被 GCD 唤醒,则执行所有调用 dispatch_async 等方法放入main queue 的 block54 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);55 &#125; else &#123;56 &#x2F;&#x2F; 如果被 source1（基于 port） 唤醒的，则处理这个事件57 __CFRunLoopDoSource1(rl, rlm, &amp;reply) || sourceHandledThisLoop;58 if (NULL !&#x3D; reply) &#123;59 mach_msg(reply, MACH_SEND_MSG);60 &#125; 61 &#125;6263 &#x2F;&#x2F; 执行加入到 loop 的 block64 __CFRunLoopDoBlocks(rl, rlm);65 66 &#x2F;&#x2F; 判断是否应该退出 loop67 if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;68 &#x2F;&#x2F; 传入的参数是否说明应该在处理完事件就返回69 retVal &#x3D; kCFRunLoopRunHandledSource;70 &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;71 &#x2F;&#x2F; 是否过期72 retVal &#x3D; kCFRunLoopRunTimedOut;73 &#125; else if (__CFRunLoopIsStopped(rl)) &#123;74 &#x2F;&#x2F; 是否被强制停止75 retVal &#x3D; kCFRunLoopRunStopped;76 &#125; else if (rlm-&gt;_stopped) &#123;77 retVal &#x3D; kCFRunLoopRunStopped;78 &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm)) &#123;79 &#x2F;&#x2F; mode 是否为空，即 source、timer 为空80 retVal &#x3D; kCFRunLoopRunFinished;81 &#125;8283 &#x2F;&#x2F; 都不是，则继续 loop84 &#125; while (0 &#x3D;&#x3D; retVal);85 86 return retVal;87&#125; 而判断 mode 的逻辑大致如下： 1__CFRunLoopModeIsEmpty() &#123;2 if (NULL !&#x3D; rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) return false;3 if (NULL !&#x3D; rlm-&gt;_sources1 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources1)) return false;4 if (NULL !&#x3D; rlm-&gt;_timers &amp;&amp; 0 &lt; CFArrayGetCount(rlm-&gt;_timers)) return false;5 return true;6&#125; 将上面代码逻辑画成图如下： 三、与 RunLoop 相关的功能1、自动释放池一般我们比较关心的是自动释放池什么时候会释放？在打印 [NSRunLoop currentRunLoop] 的结果中我们可以看到与自动释放池相关的： 1&lt;CFRunLoopObserver&gt;&#123;activities &#x3D; 0x1, callout &#x3D; _wrapRunLoopWithAutoreleasePoolHandler&#125; 2&lt;CFRunLoopObserver&gt;&#123;activities &#x3D; 0xa0, callout &#x3D; _wrapRunLoopWithAutoreleasePoolHandler&#125; 即 app 启动后，苹果会给 RunLoop 注册很多个 observers，其中有两个是跟自动释放池相关的，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()第一个 observer 监听的是 activities = 0x1（kCFRunLoopEntry），也就是在即将进入 loop 时，其回调会调用 _objc_autoreleasePoolPush() 创建自动释放池；第二个 observer 监听的是 activities = 0xa0（kCFRunLoopBeforeWaiting | kCFRunLoopExit），即监听的是准备进入睡眠和即将退出 loop 两个事件。在准备进入睡眠之前，因为睡眠可能时间很长，所以为了不占用资源先调用 _objc_autoreleasePoolPop() 释放旧的释放池，并调用 _objc_autoreleasePoolPush() 创建新建一个新的，用来装载被唤醒后要处理的事件对象；在最后即将退出 loop 时则会 _objc_autoreleasePoolPop() 释放池子。 2、界面更新在当前 RunLoop 的打印结果我们还可以看到 1&lt;CFRunLoopObserver &gt;&#123;activities &#x3D; 0xa0,callout &#x3D; _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; 即准备进入睡眠和即将退出 loop 两个时间点，会调用函数更新 UI 界面.当在操作 UI 时，某个需要变化的 UIView/CALayer 就被标记为待处理，然后被提交到一个全局的容器去，再在上面的回调执行时才会被取出来进行绘制和调整。所以如果在一次运行循环中想用如下方法设置一个 view 的两条移动路径是行不通的，因为它会把视图的属性变化汇总起来，直接让 myView 从起点移动到终点了： 1 CGRect frame &#x3D; self.myView.frame;23 &#x2F;&#x2F; 先向下移动4 frame.origin.y +&#x3D; 200;5 [UIView animateWithDuration:1 animations:^&#123;6 self.myView.frame &#x3D; frame;7 [self.myView setNeedsDisplay];8 &#125;];910 &#x2F;&#x2F; 再向右移动11 frame.origin.x +&#x3D; 200;12 [UIView animateWithDuration:1 animations:^&#123;13 self.myView.frame &#x3D; frame;14 [self.myView setNeedsDisplay];15 &#125;]; 3、RunLoop 与 GCDRunLoop 底层会用到 GCD 的东西，GCD 的某些 API 也用到了 RunLoop。如当调用了 dispatch_async(dispatch_get_main_queue(), block)时，主队列会把该 block 放到对应的线程（恰好是主线程）中，主线程的 RunLoop 会被唤醒，从消息中取得这个 block，回调 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() 来执行这个 block： 四、应用1、UIImageView 延迟加载图片给 UIImageView 设置图片可能耗时不少，如果此时要滑动 tableView 等则可能影响到界面的流畅。解决是：使用 performSelector:withObject:afterDelay:inModes: 方法，将设置图片的方法放到 DefaultMode 中执行。 2、常驻线程子线程默认是完成任务后结束。当要经常使用子线程，每次开启子线程比较耗性能。此时可以开启子线程的 RunLoop，保持 RunLoop 运行，则使子线程保持不死。AFNetworking 基于 NSURLConnection 时正是这样做的，希望在后台线程能保持活着，从而能接收到 delegate 的回调。具体做法是： 1&#x2F;* 返回一个线程 *&#x2F;2+ (NSThread *)networkRequestThread &#123;3 static NSThread *_networkRequestThread &#x3D; nil;4 static dispatch_once_t oncePredicate;5 dispatch_once(&amp;oncePredicate, ^&#123;6 &#x2F;&#x2F; 创建一个线程，并在该线程上执行下一个方法7 _networkRequestThread &#x3D; [[NSThread alloc] initWithTarget:self8 selector:@selector(networkRequestThreadEntryPoint:)9 object:nil];10 &#x2F;&#x2F; 开启线程11 [_networkRequestThread start];12 &#125;);13 return _networkRequestThread;14&#125;15&#x2F;* 在新开的线程中执行的第一个方法 *&#x2F;16+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;17 @autoreleasepool &#123;18 [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];19 &#x2F;&#x2F; 获取当前线程对应的 RunLoop20 NSRunLoop *runLoop &#x3D; [NSRunLoop currentRunLoop];21 &#x2F;&#x2F; 为 RunLoop 添加 source，模式为 DefaultMode22 [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];23 &#x2F;&#x2F; 开始运行 RunLoop24 [runLoop run];25 &#125;26&#125; 因为 RunLoop 启动前必须设置一个 mode，而 mode 要存在则至少需要一个 source / timer。所以上面的做法是为 RunLoop 的 DefaultMode 添加一个 NSMachPort 对象，虽然消息是可以通过 NSMachPort 对象发送到 loop 内，但这里添加的 port 只是为了 RunLoop 一直不退出，而没有发送什么消息。当然我们也可以添加一个超长启动时间的 timer 来既保持 RunLoop 不退出也不占用资源。 参考： CFRunLoop.c 官方文档 深入理解RunLoop 视频: iOS线下分享《RunLoop》by 孙源@sunnyxx Run, RunLoop, Run! Understanding NSRunLoop","categories":[],"tags":[{"name":"iOS 开发","slug":"iOS-开发","permalink":"http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"}]},{"title":"SDWebImage 源码分析","slug":"SDWebImage-源码分析","date":"2016-05-18T15:15:09.000Z","updated":"2016-05-21T22:04:52.000Z","comments":true,"path":"2016/05/18/SDWebImage-源码分析/","link":"","permalink":"http://yoursite.com/2016/05/18/SDWebImage-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"对于著名的第三方库 SDWebImage 我们都不陌生，它在 Github 上的功能介绍是： 提供UIImageView的一个分类，以支持网络图片的加载与缓存管理 提供一个异步的图片加载器 提供一个异步的内存+磁盘图片缓存，并会自动处理缓存过期问题","text":"对于著名的第三方库 SDWebImage 我们都不陌生，它在 Github 上的功能介绍是： 提供UIImageView的一个分类，以支持网络图片的加载与缓存管理 提供一个异步的图片加载器 提供一个异步的内存+磁盘图片缓存，并会自动处理缓存过期问题 支持GIF图片 支持WebP图片 后台图片解压缩处理 确保同一个URL的图片不被下载多次 确保虚假的URL不会被反复加载 确保下载及缓存时，主线程不被阻塞 性能好 使用 GCD 和 ARC 支持 Arm64 虽然从上面的功能看起来很复杂，但其实非常简单好用，比如在项目开发中要在 tableView/collectionView 的 cell 中异步下载图片的时候都经常会用到它，而且只需要一句话： 1[self.iconImageView sd_setImageWithURL:[NSURL URLWithString:urlString]2 placeholderImage:[UIImage imageNamed:@&quot;img_default&quot;]]; 虽然对于 SDWebImage 的具体代码实现我们平时可能不怎么关注，但学习 SDWebImage 的代码及其思想对提高我们的水平还是很有帮助的，所以本文主要从上面的这个方法入手学习主要的类和方： 一、UIImageView+WebCache在 cell 中调用： 1[self.iconImageView sd_setImageWithURL:[NSURL URLWithString:urlString]2 placeholderImage:[UIImage imageNamed:@&quot;img_default&quot;]]; 是调用了 UIImageView 的分类 UIImageView+WebCache.m 中的方法： 1- (void)sd_setImageWithURL:(NSURL *)url2 placeholderImage:(UIImage *)placeholder; 这个方法唯一的作用就是调用了另外一个包含更多参数的的方法(类似指定构造器？)，这个方法也是 UIImageView+WebCache 的核心方法： 1- (void)sd_setImageWithURL:(NSURL *)url2 placeholderImage:(UIImage *)placeholder3 options:(SDWebImageOptions)options4 progress:(SDWebImageDownloaderProgressBlock)progressBlock5 completed:(SDWebImageCompletionBlock)completedBlock; 后面三个参数默认 0 或 nil 操作缓存池 这个方法最开始要做的是： 1&#x2F;&#x2F; UIImageView+WebCache2[self sd_cancelCurrentImageLoad]; 这是在关闭当前图片的下载操作，避免重复操作，这对在 tableView 或 collectionView 被重用的 cell 尤为重要。 它调用的方法是： 1&#x2F;&#x2F; UIImageView+WebCache2- (void)sd_cancelCurrentImageLoad &#123;3 [self sd_cancelImageLoadOperationWithKey:@&quot;UIImageViewImageLoad&quot;];4&#125;56&#x2F;&#x2F; UIView+WebCacheOperation.m7- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123;8 9 &#x2F;&#x2F; 获取操作缓存池 operationDictionary10 NSMutableDictionary *operationDictionary &#x3D; [self operationDictionary];11 12 &#x2F;&#x2F; 试图从 operationDictionary 获取与键 key 对应的 操作13 id operations &#x3D; [operationDictionary objectForKey:key];14 15 &#x2F;&#x2F; 如果获取 operations 成功，则将其取消，并从缓存池中移除16 if (operations) &#123;17 if ([operations isKindOfClass:[NSArray class]]) &#123;18 for (id &lt;SDWebImageOperation&gt; operation in operations) &#123;19 if (operation) &#123;20 [operation cancel];21 &#125;22 &#125;23 &#125; else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)])&#123;24 [(id&lt;SDWebImageOperation&gt;) operations cancel];25 &#125;26 [operationDictionary removeObjectForKey:key];27 &#125;28&#125;2930&#x2F;&#x2F; UIView+WebCacheOperation.m31- (NSMutableDictionary *)operationDictionary &#123;32 33 &#x2F;&#x2F; 用 runtime 在 category 中获取之前关联的属性(操作缓存池)34 NSMutableDictionary *operations &#x3D; objc_getAssociatedObject(self, &amp;loadOperationKey);35 36 &#x2F;&#x2F; 如果获取成功，直接返回 operations37 if (operations) &#123;38 return operations;39 &#125;40 41 &#x2F;&#x2F; 如果没有，则新建一个对象，并关联属性42 operations &#x3D; [NSMutableDictionary dictionary];43 objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);44 return operations;45&#125; 可见框架中用 NSMutableDictionary 做缓存池 operationDictionary 来存储和管理操作，这个缓存池是动态关联到 UIView 上的属性。那为什么不是关联到 UIImageView 上呢？因为在 UIButton+WebCache.m 中也会调用 - (void)sd_cancelImageLoadForState:(UIControlState)state 来取消当前操作，所以把这操作缓存池关联到 UIButton 和 UIImageView 共同的父类 UIView 上了。对于来自 UIImageView 的操作都是用字符串 &quot;UIImageViewImageLoad&quot; 做 key，值为遵守协议 SDWebImageOperation 的单个对象或由其组成的数组。SDWebImageOperation 协议只声明一个方法： 1- (void)cancel; 设置占位图 在图片开始下载之前会根据 options 参数来判断要不要先给 UIImageView 设置占位图： 1if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;2 dispatch_main_async_safe(^&#123;3 self.image &#x3D; placeholder;4 &#125;);5 &#125; options 默认为 0，所以与 SDWebImageDelayPlaceholder 枚举值做 &amp; 运算的结果为非，即默认是先设置占位图。如果在 options 中选择了 SDWebImageDelayPlaceholder 则不会设置占位图，而是等图片下载完毕再设置图片。 获取图片 接下来就要调用 [SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:] 来加载图片了： 1 if (url) &#123;23 &#x2F;&#x2F; 判断，是否要在加载图片的时候添加转动的小菊花4 if ([self showActivityIndicatorView]) &#123;5 [self addActivityIndicator];6 &#125;78 __weak __typeof(self)wself &#x3D; self;9 &#x2F;&#x2F; 获取图片10 id &lt;SDWebImageOperation&gt; operation &#x3D; [SDWebImageManager.sharedManager downloadImageWithURL:url11 options:options12 progress:progressBlock13 completed:...];14 &#x2F;&#x2F; 把操作存到操作缓存池中去，方便以后再用这个 UIImageView 加载图片前先取消掉现在这个操作，避免重复操作15 [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;]; 图片加载过程结束后则会调用 downloadImageWithURL… 方法的最后一个参数 (SDWebImageCompletionWithFinishedBlock)completedBlock，要做的事情有三个：移除转动的小菊花，回到主线程设置图片,执行 completedBlock (但默认为 nil)： 1 [wself removeActivityIndicator];2 if (!wself) return;3 dispatch_main_sync_safe(^&#123;4 if (!wself) return;5 if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)6 &#123;7 completedBlock(image, error, cacheType, url);8 return;9 &#125;10 else if (image) &#123;11 wself.image &#x3D; image;12 [wself setNeedsLayout];13 &#125; else &#123;14 if ((options &amp; SDWebImageDelayPlaceholder)) &#123;15 wself.image &#x3D; placeholder;16 [wself setNeedsLayout];17 &#125;18 &#125;19 if (completedBlock &amp;&amp; finished) &#123;20 completedBlock(image, error, cacheType, url);21 &#125;22 &#125;); dispatch_main_sync_safe 的宏定义是这样的： 1#define dispatch_main_sync_safe(block)\\2 if ([NSThread isMainThread]) &#123;\\3 block();\\4 &#125; else &#123;\\5 dispatch_sync(dispatch_get_main_queue(), block);\\6 &#125; 即保证了只在主线程更新 UI 。 最后，如果传入的 url 为空，则创建 NSError 对象 error并传给 completedBlock: 1 dispatch_main_async_safe(^&#123;2 [self removeActivityIndicator];3 if (completedBlock) &#123;4 NSError *error &#x3D; [NSError errorWithDomain:SDWebImageErrorDomain5 code:-16 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];7 completedBlock(nil, error, SDImageCacheTypeNone, url);8 &#125; 至此给 UIImageView 设置图片的方法调用完毕，主要步骤是：取消操作缓存池中的操作 –&gt; 设置占位图 –&gt; 获取图片 –&gt; 回主线程更新 UI –&gt; 把当前操作加入到操作缓存池中。看似简单，但其实还有最重要的获取图片的过程还没展开学习呢，下面继续看下它是怎样从缓存、网络中获取图片的。 二、SDWebImageManager上面函数中使用了下面方法来获取图片： 1[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]; 那 SDWebImageManager 是什么呢？它又管理着什么？ 下面是 SDWebImageManager.h 中对它的介绍： The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView. 即它是隐藏在 UIImageView 的分类 UIImageView+WebCache 背后的类。它是异步下载器 SDWebImageDownloader 和缓存图片的 SDImageCache 之间的桥梁。除了在 UIView 中，在其他地方也可以直接使用它的 downloadImageWithURL:options:progress:completed: 方法来直接下载图片。 要获取 SDWebImageManager 的对象通常是使用 sharedManager 来获取单例对象： 1+ (id)sharedManager &#123;2 static dispatch_once_t once;3 static id instance;4 dispatch_once(&amp;once, ^&#123;5 instance &#x3D; [self new];6 &#125;);7 return instance;8&#125; 但它没有严格的重写 allocWithZone 等方法来保证这对象是唯一的。 接下来正式进入 downloadImageWithURL:options:progress:completed: 方法： 首先是确保 url 的正确性： 1 &#x2F;&#x2F; SDWebImageManager.m2 if ([url isKindOfClass:NSString.class]) &#123;3 url &#x3D; [NSURL URLWithString:(NSString *)url];4 &#125;5 if (![url isKindOfClass:NSURL.class]) &#123;6 url &#x3D; nil;7 &#125; SDWebImageCombinedOperation 接着创建 operation： 1 __block SDWebImageCombinedOperation *operation &#x3D; [SDWebImageCombinedOperation new];2 __weak SDWebImageCombinedOperation *weakOperation &#x3D; operation; SDWebImageCombinedOperation 是一个继承自 NSObject、遵守了 SDWebImageOperation 协议的类，SDWebImageOperation 协议只有一个方法： 1@protocol SDWebImageOperation &lt;NSObject&gt;23- (void)cancel;45@end SDWebImageCombinedOperation 对 cancel 方法的实现只是把它持有的 NSOperation 属性 cancel 掉，以及回调并清空 cancelBlock： 1- (void)cancel &#123;2 self.cancelled &#x3D; YES;3 if (self.cacheOperation) &#123;4 &#x2F;&#x2F; cacheOperation 属性是一个 NSOperation 对象5 [self.cacheOperation cancel];6 self.cacheOperation &#x3D; nil;7 &#125;8 if (self.cancelBlock) &#123;9 self.cancelBlock();10 _cancelBlock &#x3D; nil;11 &#125;12&#125; 接着判断 url 是否在之前加载失败的 url 记录中： 1 BOOL isFailedUrl &#x3D; NO;2 @synchronized (self.failedURLs) &#123;3 isFailedUrl &#x3D; [self.failedURLs containsObject:url];4 &#125; 后面我们可以看到如果这个 url 加载失败，则会被记录，以此保证无效的 url 不会被重复加载。 接着用该 url 生成对应的 key，并用此 key 到缓存中查找有没对应的图片： 1 NSString *key &#x3D; [self cacheKeyForURL:url];2 operation.cacheOperation &#x3D;3 [self.imageCache queryDiskCacheForKey:key4 done:^(UIImage *image, SDImageCacheType cacheType); 由 url 生成 key 的过程也很简单，默认只是 url 的字符串形式： 1- (NSString *)cacheKeyForURL:(NSURL *)url &#123;2 if (self.cacheKeyFilter) &#123;3 return self.cacheKeyFilter(url);4 &#125;5 else &#123;6 return [url absoluteString];7 &#125;8&#125; 如果在缓存中找到了对应的图片，则直接回调并返回该图片： 1dispatch_main_sync_safe(^&#123;2 completedBlock(image, nil, cacheType, YES, url);3&#125;); 如果没有在缓存中找到对应的图片，则到网络下载： 1id &lt;SDWebImageOperation&gt; subOperation &#x3D;2[self.imageDownloader downloadImageWithURL:url3 options:downloaderOptions4 progress:progressBlock5 completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished)&#123;...&#125;]; 这个方法返回遵守了 SDWebImageOperation 协议的对象 subOperation。如果这个方法下载到了图片，则先在图片缓存中存储这个图片，再回执行回调 block: 1if (downloadedImage &amp;&amp; finished) &#123;2 [self.imageCache storeImage:downloadedImage3 recalculateFromImage:NO4 imageData:data5 forKey:key6 toDisk:cacheOnDisk];7&#125;8dispatch_main_sync_safe(^&#123;9 if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;10 completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);11 &#125;12&#125;); 如果图片要进行转换，则先进行转换，再存储和返回转换后的图片。 如果图片不在缓存中，而且其代理也不支持到网络下载，则图片为 nil： 1dispatch_main_sync_safe(^&#123;2 __strong __typeof(weakOperation) strongOperation &#x3D; weakOperation;3 if (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;4 completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);5 &#125;6&#125;); 至此用 SDWebImageManager 的对象方法 downloadImageWithURL:options:progress:completed: 获取图片已经结束，主要是先后从缓存、网络中获取图片，如果获取成功，则存储起来并返回图片。下面将继续学习图片缓存和到网络加载图片的两个过程。 三、SDImageCacheSDImageCache.h 中对 SDImageCache 类是这样介绍的： SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI. 即它维护了一个内存缓存和一个磁盘缓存，后一个缓存不是必须的。磁盘缓存的写入操作是异步的，所以它不会给 UI 造成延迟。在上一节的方法中是用到了它的对象方法来异步查询图片缓存： 1- (NSOperation *)queryDiskCacheForKey:(NSString *)key2 done:(SDWebImageQueryCompletedBlock)doneBlock; 这个方法先在内存中查找是否有图片缓存，如果有，则回调： 1 &#x2F;&#x2F; First check the in-memory cache...2 UIImage *image &#x3D; [self imageFromMemoryCacheForKey:key];3 if (image) &#123;4 doneBlock(image, SDImageCacheTypeMemory);5 return nil;6 &#125; 这里用到的 imageFromMemoryCacheForKey 方法会在 SDImageCache 的属性 memCache 中查找。memCache 是一个 NSCache 对象。 1&#x2F;&#x2F; SDImageCache.m2@property (strong, nonatomic) NSCache *memCache;34- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123;5 return [self.memCache objectForKey:key];6&#125; 如果内存中没有，则从磁盘中查找并回调，如果找到则先保存到内存中，下次再要从缓存中查找则可先在内存中获取了。 1 UIImage *diskImage &#x3D; [self diskImageForKey:key];2 if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;3 NSUInteger cost &#x3D; SDCacheCostForImage(diskImage);4 [self.memCache setObject:diskImage forKey:key cost:cost];5 &#125;6 7 dispatch_async(dispatch_get_main_queue(), ^&#123;8 doneBlock(diskImage, SDImageCacheTypeDisk);9 &#125;); 在磁盘中查找的路径是 沙盒的 Cache 文件夹 + 文件名。 其中 Cache 文件夹路径为： 1&#x2F;&#x2F; SDImageCache.m2NSArray *paths &#x3D; NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); 文件名则比较复杂，是先将 key 作 MD5 转换，得到 16 个字符，将每个字符的 ASCII 码表示为两位的十六进制形式，然后拼起来，得到一个 32 个数字组成的文件名，如果有后缀则再加上后缀。 1&#x2F;&#x2F; SDImageCache.m2#define CC_MD5_DIGEST_LENGTH 1634- (NSString *)cachedFileNameForKey:(NSString *)key &#123;5 const char *str &#x3D; [key UTF8String];6 if (str &#x3D;&#x3D; NULL) &#123;7 str &#x3D; &quot;&quot;;8 &#125;9 unsigned char r[CC_MD5_DIGEST_LENGTH];10 CC_MD5(str, (CC_LONG)strlen(str), r);11 NSString *filename &#x3D;12 [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,13 r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15],14 [[key pathExtension] isEqualToString:@&quot;&quot;] ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, [key pathExtension]]];1516 return filename;17&#125; SDImageCache 类还会自动处理缓存过期问题。图片缓存最久能保持一周： 1&#x2F;&#x2F; SDImageCache.m2static const NSInteger kDefaultCacheMaxCacheAge &#x3D; 60 * 60 * 24 * 7; &#x2F;&#x2F; 1 week 在程序结束的时候进行两次磁盘清理，第一次是将过期的文件清除： 1&#x2F;&#x2F; SDImageCache.m2&#x2F;&#x2F; 根据最大缓存时间计算出 过期日期3NSDate *expirationDate &#x3D; [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];4...5NSDate *modificationDate &#x3D; resourceValues[NSURLContentModificationDateKey];6if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;7 [urlsToDelete addObject:fileURL];8 continue;9&#125; 第二次是判断此时文件缓存是否大于配置的最大文件容量，如果是，则从老到新清除文件，直至文件缓存小于最大文件容量的一半： 1&#x2F;&#x2F; SDImageCache.m2...3const NSUInteger desiredCacheSize &#x3D; self.maxCacheSize &#x2F; 2;4...5&#x2F;&#x2F; 对所有缓存文件，按最后修改时间排序6NSArray *sortedFiles &#x3D; [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent7 usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;8 return [obj1[NSURLContentModificationDateKey]9 compare:obj2[NSURLContentModificationDateKey]];10 &#125;];1112&#x2F;&#x2F; 删除文件，直至文件缓存足够小13for (NSURL *fileURL in sortedFiles) &#123;14 if ([_fileManager removeItemAtURL:fileURL error:nil]) &#123;15 NSDictionary *resourceValues &#x3D; cacheFiles[fileURL];16 NSNumber *totalAllocatedSize &#x3D; resourceValues[NSURLTotalFileAllocatedSizeKey];17 currentCacheSize -&#x3D; [totalAllocatedSize unsignedIntegerValue];18 if (currentCacheSize &lt; desiredCacheSize) &#123;19 break;20 &#125;21 &#125;22&#125;23... 这就是 SDImageCache 类处理图片缓存的核心内容了。 如果在缓存中没能找到对应的图片，则需要到网络下载了，所以我们接着学习图片的下载过程。 四、SDWebImageDownloaderSDWebImageDownloader.h 中对 SDWebImageDownloader 类的简介是： Asynchronous downloader dedicated and optimized for image loading. 即它是经过优化了的专门用来异步下载图片的。 在 SDWebImageManager 的 downloadImageWithURL:options:progress:completed: 方法中正是使用下面的 SDWebImageDownloader 的对象方法来下载图片的： 1- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url2 options:(SDWebImageDownloaderOptions)options3 progress:(SDWebImageDownloaderProgressBlock)progressBlock4 completed:(SDWebImageDownloaderCompletedBlock)completedBlock; 但这个方法几乎调用了另一个方法： 1- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock2 completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock3 forURL:(NSURL *)url4 createCallback:(SDWebImageNoParamsBlock)createCallback; 但它主要是定义了上面方法的最后一个参数 createCallback。 先看下 addProgressCallback:completedBlock:forURL:createCallback: 方法干了些什么： 1&#x2F;&#x2F; SDWebImageDownloader.m23 dispatch_barrier_sync(self.barrierQueue, ^&#123;4 BOOL first &#x3D; NO;5 &#x2F;&#x2F; 先查看 URLCallbacks 属性（NSMutableDictionary 类的）中有没与该 url 对应的 callbacksForURL6 &#x2F;&#x2F; 如果没有，则新建一个可变数组7 if (!self.URLCallbacks[url]) &#123;8 self.URLCallbacks[url] &#x3D; [NSMutableArray new];9 first &#x3D; YES;10 &#125;1112 &#x2F;&#x2F; Handle single download of simultaneous download request for the same URL13 NSMutableArray *callbacksForURL &#x3D; self.URLCallbacks[url];14 NSMutableDictionary *callbacks &#x3D; [NSMutableDictionary new];15 if (progressBlock) callbacks[kProgressCallbackKey] &#x3D; [progressBlock copy];16 if (completedBlock) callbacks[kCompletedCallbackKey] &#x3D; [completedBlock copy];17 [callbacksForURL addObject:callbacks];18 self.URLCallbacks[url] &#x3D; callbacksForURL;19 20 &#x2F;&#x2F; 如果是第一次添加回调，则执行回调，做 初始化请求 等操作21 if (first) &#123;22 createCallback();23 &#125;24 &#125;); 即该方法主要是把 progressBlock 和 completedBlock 存进与 url 对应的数组 callbacksForURL 中,方便以后取用, 并且在一次添加回调时会执行传入的参数 createCallback，这个就是在 downloadImageWithURL:options:progress:completed: 方法中定义的，它的内容如下： 1&#x2F;&#x2F; 设置超时时间，默认为 15s2NSTimeInterval timeoutInterval &#x3D; wself.downloadTimeout;3if (timeoutInterval &#x3D;&#x3D; 0.0) &#123;4 timeoutInterval &#x3D; 15.0;5&#125;6&#x2F;&#x2F; 创建并设置一个可变请求7NSMutableURLRequest *request &#x3D; [[NSMutableURLRequest alloc] initWithURL:url...8request.HTTPShouldHandleCookies &#x3D; (options &amp; SDWebImageDownloaderHandleCookies);9request.HTTPShouldUsePipelining &#x3D; YES; 然后创建一个 SDWebImageDownloaderOperation 类的对象 operation，并在这定义以后在监听下载过程的代理方法中会调用的三个 block（progressBlock(主要是执行存储在上面的 callbacksForURL 中的progressBlock)，completedBlock(主要是执行存储在上面的 callbacksForURL 中的completedBlock)，cancelBlock (移除 url 对应的 callbacksForURL)）： 1&#x2F;&#x2F; SDWebImageDownloader.m2operation &#x3D; [[wself.operationClass alloc] initWithRequest:request3 options:options4 progress:5 completed:6 cancelled:...]; 然后把这个操作添加到队列中，使得开始执行操作，如果设置了操作的顺序是后进先出，还得设置操作之间的依赖关系： 1 [wself.downloadQueue addOperation:operation];23 if (wself.executionOrder &#x3D;&#x3D; SDWebImageDownloaderLIFOExecutionOrder) &#123;4 [wself.lastAddedOperation addDependency:operation];5 wself.lastAddedOperation &#x3D; operation;6 &#125; SDWebImageDownloaderOperation 上面说到的 operation 是 SDWebImageDownloaderOperation 类的实例，SDWebImageDownloaderOperation 类继承自 NSOperation，用于处理 HTTP 请求，URL 连接等。operation 被加入队列后，就会调用 start 方法： 1&#x2F;&#x2F; SDWebImageDownloaderOperation.m2- (void)start &#123;3 @synchronized (self) &#123;4 &#x2F;&#x2F; 如果被标记为 cancell，则清空属性并返回5 if (self.isCancelled) &#123;6 self.finished &#x3D; YES;7 [self reset];8 return;9 &#125;10 &#x2F;&#x2F; 创建一个 NSURLConnection 对象11 self.executing &#x3D; YES;12 self.connection &#x3D; [[NSURLConnection alloc] initWithRequest:self.request13 delegate:self14 startImmediately:NO];15 self.thread &#x3D; [NSThread currentThread];16 &#125;17 18 &#x2F;&#x2F; 新创建的 NSURLConnection 对象开始执行19 [self.connection start];2021 if (self.connection) &#123;22 &#x2F;&#x2F; 如果 connection 创建成功，则开始调用 progressBlock，初始接收到的数据大小为 023 if (self.progressBlock) &#123;24 self.progressBlock(0, NSURLResponseUnknownLength);25 &#125;26 &#x2F;&#x2F; 回到主线程，发出“开始下载”的通知27 dispatch_async(dispatch_get_main_queue(), ^&#123;28 [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification29 object:self];30 &#125;);31 &#x2F;&#x2F; 开启子线程的 RunLoop32 if (floor(NSFoundationVersionNumber) &lt;&#x3D; NSFoundationVersionNumber_iOS_5_1) &#123;33 CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);34 &#125;35 else &#123;36 CFRunLoopRun();37 &#125;3839 if (!self.isFinished) &#123;40 [self.connection cancel];41 [self connection:self.connection42 didFailWithError:[NSError errorWithDomain:NSURLErrorDomain43 code:NSURLErrorTimedOut44 userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]];45 &#125;46 &#125;47 &#x2F;&#x2F; 如果 connection 创建失败，则调用 completedBlock，返回的图片和数据都为 nil48 else &#123;49 if (self.completedBlock) &#123;50 self.completedBlock(nil,51 nil,52 [NSError errorWithDomain:NSURLErrorDomain53 code:054 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Connection can&#39;t be initialized&quot;&#125;],55 YES);56 &#125;57 &#125;58&#125; 五、NSURLConnectionDataDelegate在下载过程中 NSURLConnection 的代理会监听下载情况并调用以下三种方法: 1- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response; (接收到服务器返回的 response 时调用该代理方法,一般调用一次(除非 HTTP 内容类型是 multipart/x-mixed-replace 才会收到多个 response)，主要作用是执行属性 progressBlock,回主线程发送接收到 response 的通知.如果出错则执行 cancelBlock 和 completedBlock) 1- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data; (每次接收到服务器返回的数据时调用该代理方法, 主要作用是用一个 CGImageSourceRef 对象对现有数据进行处理、生成图片供回调使用,并调用属性 progressBlock, 提示下载进度) 1- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection； (结束加载时调用该方法, 主要作用是停止子线程的 RunLoop ,调用属性 completionBlock ,返回下载到的图片,或错误, completionBlock 则会更新图片) 最后SDWebImage 的图片加载流程大致如下，但没把操作缓存池、图片下载完先存储到缓存等操作画上去： 参考： SDWebImage How is SDWebImage better than X? iOS 源代码分析 — SDWebImage SDWebImage实现分析 Is there a big advantage to using SDWebImage over AFNetworking for image loading? iOS图片缓存库基准对比","categories":[],"tags":[{"name":"iOS 开发","slug":"iOS-开发","permalink":"http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"}]},{"title":"利用 class-dump 和 Hopper Disassembler 反编译app","slug":"利用-class-dump-和-Hopper-Disassembler-反编译app","date":"2016-05-02T08:12:49.000Z","updated":"2016-05-19T11:56:05.000Z","comments":true,"path":"2016/05/02/利用-class-dump-和-Hopper-Disassembler-反编译app/","link":"","permalink":"http://yoursite.com/2016/05/02/%E5%88%A9%E7%94%A8-class-dump-%E5%92%8C-Hopper-Disassembler-%E5%8F%8D%E7%BC%96%E8%AF%91app/","excerpt":"一、利用 class-dump 查看属性、成员变量、方法声明和实现地址只需三步： 1. 安装 class-dump 。 2. 获得 app 的程序文件。 3. 用 class-dump 从 app 的程序文件中 dump 出头文件。","text":"一、利用 class-dump 查看属性、成员变量、方法声明和实现地址只需三步： 1. 安装 class-dump 。 2. 获得 app 的程序文件。 3. 用 class-dump 从 app 的程序文件中 dump 出头文件。 具体如下：先下载 class-dump-3.5.dmg, 把下载到的 dmg 文件打开： 把 class-dump 文件放到这里： 打开终端，输入 class-dump 查看版本，如果是以下信息则安装成功： 接着用 Xcode 新建一个 project， 在 ViewController 类中添加一些公开和私有的属性、成员变量、方法声明和实现： . 运行程序，在 bundle 目录下： 打开包内容： 把 DecompileDemo 程序文件复制到桌面某文件夹中，在终端输入以下指令： 此时可以看到头文件已导出： 打开 ViewController.h 可以看到： 所以，不仅公开的属性、成员变量、方法声明，而且私有的属性、成员变量、方法声明也被 dump 出来了。用这个指令： 还可以看到方法实现的地址： 二、 利用 Hopper Disassembler 进行反编译、反汇编 官网下载: http://www.hopperapp.com/download.html? 使用：打开软件，然后直接把上面得到的二进制文件拖进去即可得到： 如果懂汇编的话，也可以结合绿色的注释了解方法的实现。对于像我这样不懂汇编的，也可以点击右上角的： 生成伪代码，基本可以理解方法的具体实现了(self, _cmd 是 OC 的每个方法中隐藏的两个参数)。 . 即使是私有方法也被反编译出来了！ 当然了，这只是反编译 app 的一小尝试，要反编译 App Store 上的 app 可没那么简单。","categories":[],"tags":[{"name":"iOS 开发","slug":"iOS-开发","permalink":"http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"}]},{"title":"OC中Method Swizzling的原理及应用","slug":"OC中Method-Swizzling的原理及应用","date":"2016-04-05T14:05:06.000Z","updated":"2016-05-19T11:55:53.000Z","comments":true,"path":"2016/04/05/OC中Method-Swizzling的原理及应用/","link":"","permalink":"http://yoursite.com/2016/04/05/OC%E4%B8%ADMethod-Swizzling%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/","excerpt":"一、前言：我们知道如果要在没有一个类的实现源码的情况下，要改变某方法的实现，可以通过：（1）继承该类然后用子类重写的方法，这个比较常用；（2）也可以为该类添加分类(category)，实现一个同名方法覆盖原方法，这个很少用，因为这样也会影响该类的子类调用它的方法。这里要介绍第三种方法，就是利用Objective-C强大的runtime特性实现的——Method Swizzling。","text":"一、前言：我们知道如果要在没有一个类的实现源码的情况下，要改变某方法的实现，可以通过：（1）继承该类然后用子类重写的方法，这个比较常用；（2）也可以为该类添加分类(category)，实现一个同名方法覆盖原方法，这个很少用，因为这样也会影响该类的子类调用它的方法。这里要介绍第三种方法，就是利用Objective-C强大的runtime特性实现的——Method Swizzling。 二、原理：在OC中调用一个对象的某个方法，其实是给一个对象发送消息，这个消息在运行时才被对象接收到.对象查找消息的顺序是：缓存(如果之前调用过同样的方法的话) –&gt; 所属的类 –&gt; 所属的类的父类 –&gt; 所属的类的父类的父类 –&gt; … —&gt; NSObject，如果最后没找到，则报错。那这个只有消息(方法)名,怎么找到相应实现代码呢? 原来该对象的类(或其父类等)都有方法的列表,存放着selectore的名字和方法实现(IMP)的映射关系,而这些IMP正是指向方法实现代码块的指针(类似函数指针).所以对象查找拿到方法名后将其包装成SEL类型的selector,然后拿着这个selector,到通过isa指针找到所属的类(或其父类等)去匹配,找到名字相同的selector则匹配成功,最后执行对应的实现代码. 简单来说,从接收到消息到执行的过程是: 把方法名包装成SEL à 用名字匹配找到对应的selector à 由selector执行对应的方法实现代码块,而Method Swizzling 则是通过改动最后一个过程,调换selector对应的方法实现,从而达到改变某个方法的实现.如函数 method_exchangeImplementations(Method m1, Method m2) 的原子性(atomic)版的实现过程是: 1IMP imp1 &#x3D; method_getImplementation(m1);2IMP imp2 &#x3D; method_getImplementation(m2);3method_setImplementation(m1, imp2);4method_setImplementation(m2, imp1); method_getImplementation是获取某方法的IMP, method_setImplementation 是设置某方法的IMP.虽然Method Swizzling是非原子性的,为了解决安全性和并发性问题,只要将其放在类的load方法里实现就可以了,因为一个类的load只会执行一次. 三、应用那这些方法有什么用处呢?下面我们来设置一个需求:如果你之前做的某个软件的3按钮通过下面代码设置了3个图片: 1- (void)setupImage&#123;2 self.starImageView.image &#x3D; [UIImage imageNamed:@&quot;star&quot;];3 self.circleImageView.image &#x3D; [UIImage imageNamed:@&quot;circle&quot;];4 self.rectImageView.image &#x3D; [UIImage imageNamed:@&quot;rect&quot;];5&#125; 而后来你希望用户能通过自己的喜好来选择软件的风格,即换肤,所以你想提供红绿蓝三种风格. 一种比较简单粗暴的做法是分别设置3种风格下的三个图片: 1- (void)viewDidLoad &#123;2 [super viewDidLoad];3 4 [self setImagesWithRedSkin];5&#125;6- (IBAction)changeSkinsBtnClick:(UIButton *)sender &#123;7 switch (sender.tag) &#123;8 case 1:9 [self setImagesWithRedSkin];10 break;11 case 2:12 [self setImagesWithGreenSkin];13 break;14 case 3:15 [self setImagesWithBlueSkin];16 break;17 default:18 break;19 &#125;20&#125;2122&#x2F;* remember choose &quot;Create folder references&quot; when dragging the images into the project *&#x2F;23- (void)setImagesWithRedSkin&#123;24 self.starImageView.image &#x3D; [UIImage imageNamed:@&quot;skin&#x2F;red&#x2F;star&quot;];25 self.circleImageView.image &#x3D; [UIImage imageNamed:@&quot;skin&#x2F;red&#x2F;circle&quot;];26 self.rectImageView.image &#x3D; [UIImage imageNamed:@&quot;skin&#x2F;red&#x2F;rect&quot;];27&#125;28- (void)setImagesWithGreenSkin&#123;29 self.starImageView.image &#x3D; [UIImage imageNamed:@&quot;skin&#x2F;green&#x2F;star&quot;];30 self.circleImageView.image &#x3D; [UIImage imageNamed:@&quot;skin&#x2F;green&#x2F;circle&quot;];31 self.rectImageView.image &#x3D; [UIImage imageNamed:@&quot;skin&#x2F;green&#x2F;rect&quot;];32&#125;33- (void)setImagesWithBlueSkin&#123;34 self.starImageView.image &#x3D; [UIImage imageNamed:@&quot;skin&#x2F;blue&#x2F;star&quot;];35 self.circleImageView.image &#x3D; [UIImage imageNamed:@&quot;skin&#x2F;blue&#x2F;circle&quot;];36 self.rectImageView.image &#x3D; [UIImage imageNamed:@&quot;skin&#x2F;blue&#x2F;rect&quot;];37&#125; 现在看起来还不是太麻烦,但如果要有10种风格,每种风格要用到10张图片,岂不是要修改10*10次?如果更多呢?这是可以考虑用Method Swizzling,保持原来的设置图片的代码: 1- (void)setupImage&#123;2 self.starImageView.image &#x3D; [UIImage imageNamed:@&quot;star&quot;];3 self.circleImageView.image &#x3D; [UIImage imageNamed:@&quot;circle&quot;];4 self.rectImageView.image &#x3D; [UIImage imageNamed:@&quot;rect&quot;];5&#125; 在用户点击变换风格的时候选择风格,然后在执行设置图片时要判断用户选择了哪种风格,然后根据不同风格设置不同路径的图片 1- (IBAction)changeSkinSBtnClick:(UIButton *)sender &#123;2 [YGImage setMode:YGImageModeSkin];3 4 &#x2F;&#x2F; select a style according to the sender5 switch (sender.tag) &#123;6 case 1:7 [YGSkin setStyel:YGSkinStyleRed];8 break;9 case 2:10 [YGSkin setStyel:YGSkinStyleGreen];11 break;12 case 3:13 [YGSkin setStyel:YGSkinStyleBlue];14 break;15 default:16 break;17 &#125;18 19 [self setupImage];20&#125; 其中[YGImage setMode:YGImageModeSkin] 是用来表示进入换肤模式,[YGSkin setStyel :YGSkinStyleRed] 是表示具体选择了哪种风格的皮肤. 而新的执行方法和调换过程则放在UIImage的分类 UIImage+Swizzle 中: 1@implementation UIImage (Swizzle)2 3&#x2F;* we can exchange custom methods and system methods in class method &quot;+ load&quot; *&#x2F;4+ (void)load&#123;5 6 static dispatch_once_t oneToken;7 dispatch_once(&amp;oneToken, ^&#123;8 9 Method originalMethod &#x3D; class_getClassMethod([self class], @selector(imageNamed:));10 Method newMethod &#x3D; class_getClassMethod([self class], @selector(newImageNamed:));11 12 method_exchangeImplementations(originalMethod, newMethod);13 &#125;);14&#125;15 16&#x2F;* new method used to be exchanged with the older one *&#x2F;17+ (UIImage *)newImageNamed:(NSString *)imageName&#123;18 19 NSString *fullImageName &#x3D; imageName;20 21 if ([YGImage mode] &#x3D;&#x3D; YGImageModeSkin) &#123;22 switch ([YGSkin style]) &#123;23 case YGSkinStyleRed:24 fullImageName &#x3D; [NSString stringWithFormat:@&quot;skin&#x2F;red&#x2F;%@&quot;, imageName];25 break;26 case YGSkinStyleGreen:27 fullImageName &#x3D; [NSString stringWithFormat:@&quot;skin&#x2F;green&#x2F;%@&quot;, imageName];28 break;29 case YGSkinStyleBlue:30 fullImageName &#x3D; [NSString stringWithFormat:@&quot;skin&#x2F;blue&#x2F;%@&quot;, imageName];31 break;32 default:33 break;34 &#125;35 &#125;36 37 return [UIImage newImageNamed:fullImageName]; &#x2F;&#x2F; actually call - imageNamed:38&#125;39@end 注意到Method Swizzling应放在某个类的类方法+(void)load中,并在应用程序的一开始就执行, 并用dispatch_once确保代码只被执行一次(貌似也可以不需要).可能你会好奇:在newImageNamed方法中最后调用自身不会形成无限循环么?其实这时已经完成了方法调换,所以调用是原方法 imageNamed 呢.这样用Method Swizzling实现换肤功能就完成了. 四、其他例子(1) github上的 JRSwizzle 把封装了起来,使用比较方便,只需要: 1NSError *error &#x3D;nil;2[UIImage jr_swizzleClassMethod:@selector(imageNamed:) withClassMethod:@selector(newImageNamed:) error:&amp;error]; 即可交换两方法. 其中的实现也是用到了: 1Method origMethod &#x3D; class_getInstanceMethod(self, origSel_);2Method altMethod &#x3D; class_getInstanceMethod(self, altSel_);34class_addMethod(self,5 origSel_,6 class_getMethodImplementation(self, origSel_),7 method_getTypeEncoding(origMethod));8class_addMethod(self,9 altSel_,10 class_getMethodImplementation(self, altSel_),11 method_getTypeEncoding(altMethod));1213method_exchangeImplementations(class_getInstanceMethod(self, origSel_), class_getInstanceMethod(self, altSel_)); (2) github上还有个库 UIViewController-Swizzled ,是用来用新的方法调换了原viewController的viewDidAppear方法,打印当前的viewController的名字和深度,有助于开发者处理项目大量的复杂的viewController,其中交换方法的代码是: 1static void swizzInstance(Class class, SEL originalSelector, SEL swizzledSelector)2&#123;3 Method originalMethod &#x3D; class_getInstanceMethod(class, originalSelector);4 Method swizzledMethod &#x3D; class_getInstanceMethod(class, swizzledSelector);5 6 BOOL didAddMethod &#x3D;7 class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));8 9 if (didAddMethod)10 &#123;11 class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod),method_getTypeEncoding(originalMethod));12 &#125;13 else14 &#123;15 method_exchangeImplementations(originalMethod, swizzledMethod);16 &#125;17&#125; 源代码见：我的Demo 延伸阅读: Objective-C的hook方案（一）: Method Swizzling Method Swizzling Objective-C Runtime 运行时之四：Method Swizzling Method Swizzling 和 AOP 实践","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}]},{"title":"修饰 outlet 用 Strong 还是 Weak?","slug":"修饰-outlet-用-Strong-还是Weak","date":"2016-03-28T14:11:32.000Z","updated":"2016-05-19T17:12:07.000Z","comments":true,"path":"2016/03/28/修饰-outlet-用-Strong-还是Weak/","link":"","permalink":"http://yoursite.com/2016/03/28/%E4%BF%AE%E9%A5%B0-outlet-%E7%94%A8-Strong-%E8%BF%98%E6%98%AFWeak/","excerpt":"Outlet是一个对象的属性(property),这个属性引用了另外一个对象(在nib文件中),它们的引用关系被Interface Builder记录着,每次nib文件被使用来生成视图时,这些引用关系都会被创建,使得该nib文件中的对象与另一个对象中被标记为outlet的属性产生联系.如: 1@interface GallantViewController : UIViewController2@property (nonatomic, weak) IBOutlet UISwitch *switch;3@end","text":"Outlet是一个对象的属性(property),这个属性引用了另外一个对象(在nib文件中),它们的引用关系被Interface Builder记录着,每次nib文件被使用来生成视图时,这些引用关系都会被创建,使得该nib文件中的对象与另一个对象中被标记为outlet的属性产生联系.如: 1@interface GallantViewController : UIViewController2@property (nonatomic, weak) IBOutlet UISwitch *switch;3@end 而IBOutlet不是OC中的语法,只是在Xcode中为了让Interface Builder更好的识别出一个属性是outlet而添加的.它的宏定义如下: 1#define IBOutlet 由Clang可知,实际上它是被编译器定义成: 1#define IBOutlet __attribute__((iboutlet)) 和其他属性一样,被用作outlet的属性也可用weak(在MRC下用assign)或strong来修饰,而strong 是默认的.在app通常用outlet来连接自定义的控制器对象和用户界面上的对象. 官方文档认为:一个outlet应该使用weak来声明为弱引用,除非是从File’s Owner到nib文件中的顶层(top-level)对象(如storyboard scene).理由有:(1) 因为这样可以避免循环引用问题;(2) 那些指向视图控制器的view或窗口控制器的window的子视图,只是对象间比较随意的引用,并没用拥有关系,所以不应用strong(3) 用strong修饰的outlet通常是在框架类来制定(如视图控制器的视图outlet) 1@property (weak) IBOutlet MyView *viewContainerSubview;23@property (strong) IBOutlet MyOtherClass *topLevelObject; 但又指出outlet越多,占用的内存也越多.所以推荐使用其他方法来引用Interface Builder上的对象,如在矩阵中的位置,函数参数,或者用tag.也有些情况应该用strong修饰outlet:(1) 从File’s Owner到nib文件中的顶层对象;(2) 在希望某nib文件中的对象能在脱离它原来的容器还存活的情况.如想要使用一个视图,而这个视图随时可能从其所在的视图层次(view hierarchy)中被删除,则可用strong来修饰与这个视图的outlet,使之能独立存在. 而在WWDC 2015的”Implementing UI Designs in Interface Builder”会议,则有个Apple的工程师说:“通常你应该用strong来修饰你的outlet,尤其是当你要连接一个outlet到子视图或者在视图层次中不总是被持有的constraint(约束?)时.只有当你用自定义的视图来引用一个东东,而这个东东反过来又引用了视图层次时才需要用weak,但还是不推荐这么做.” 也有人认为从性能方面论证应该尽量用Strong来修饰outlet：访问weak修饰的属性效率更低.因为访问一个strong,nonatomic的属性只是读取和返回一个指针值,而访问一个weak,nonatomic的属性需要几步:确认该对象未被标记为deallocated,对其值使用retain和autorelease(否则返回的指针随时可能无效),要访问的每部分还要被锁上.weak修饰outlet虽然在释放顶层视图时免了显式清除,但卸载(unload)顶层视图本来就很难正确,所以Apple在iOS6之后就不用unload了. 另外，在Swift中，修饰属性的不仅有strong/weak，还有可选类型的”!”或”?”。这时情况可分一下几种：（1） 如果可以保证一个视图总会存在，则用strong + ”!”,这样访问outlet属性总能有值。这种也是最常用的。 1@IBOutlet private var someLabel: UILabel! （2） 如果一个视图有可能不作为视图层次结构中的一部分而存在时，则用strong + ”?”，这样说明访问outlet时不一定能保证有值. 1@IBOutlet private var someLabel: UILabel? （3） 如果一个视图从视图层次结构中移除后不再需要被用到，则可以用weak + “?”使得该视图被移除后释放内存。 1@IBOutlet private weak var someLabel: UILabel? 参考： Strong Feelings on Weak Outlets IBAction / IBOutlet / IBOutlet​Collection Outlets: Strong! Or Weak? IBOutlets strong or weak Outlets ARC下IBOutlet用weak还是strong","categories":[],"tags":[{"name":"iOS 开发","slug":"iOS-开发","permalink":"http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"}]},{"title":"谈谈 Swift中的 lazy 属性","slug":"谈谈-Swift中的-lazy-属性","date":"2016-03-21T06:29:27.000Z","updated":"2016-05-19T17:03:20.000Z","comments":true,"path":"2016/03/21/谈谈-Swift中的-lazy-属性/","link":"","permalink":"http://yoursite.com/2016/03/21/%E8%B0%88%E8%B0%88-Swift%E4%B8%AD%E7%9A%84-lazy-%E5%B1%9E%E6%80%A7/","excerpt":"1.OC中的懒加载:在OC中,为了提高程序的性能,经常使用懒加载来加载一些诸如读取文件,分配内存,加载内容非常复杂的内容等耗时耗内存的操作. 如在控制器中延迟加载一个模型,通常这样重写该getter:","text":"1.OC中的懒加载:在OC中,为了提高程序的性能,经常使用懒加载来加载一些诸如读取文件,分配内存,加载内容非常复杂的内容等耗时耗内存的操作. 如在控制器中延迟加载一个模型,通常这样重写该getter: 1@interface ViewController ()2@property (strong, nonatomic) PersonInfo *personInfo;3@end4 5@implementation ViewController6 7- (PersonInfo *)personInfos&#123;8 if (!_personInfo) &#123;9 _personInfo &#x3D; [[PersonInfo alloc] init];10 NSLog(@&quot;此处有耗性能操作&quot;);11 &#125;12 return _personInfo;13&#125; 初始化控制器对象后, _personInfo为nil,等到第一次要使用到该属性时才调用其getter来创建,而以后要使用则不再创建对象,而是直接返回该属性. 2. Swift中的懒加载:在swift中可用关键字lazy来修饰struct或class的成员变量,从而实现懒加载的效果: 1import UIKit23class Person &#123;4&#125;56class ViewController: UIViewController &#123;7 8 lazy var person:Person &#x3D; &#123;9 var tmpPerson &#x3D; Person()10 print(&quot;此处有耗性能操作&quot;)11 return tmpPerson12 &#125;()13 14 override func viewDidLoad() &#123;15 super.viewDidLoad()16 someFunc()17 someFunc()18 &#125;1920 func someFunc()&#123;21 print(person)22 &#125;23&#125;24&#x2F;&#x2F;此处有耗性能操作25&#x2F;&#x2F;LazyTest.Person26&#x2F;&#x2F;LazyTest.Person 闭包在第一次调用的时候调用,之后就不调用了.当然这些耗性能的操作也可以在类的构造方法中执行: 1import UIKit23class Person &#123;4 init()&#123;5 print(&quot;此处有耗性能操作&quot;)6 &#125;7&#125;89class ViewController: UIViewController &#123;10 11 lazy var person &#x3D; Person()12 13 override func viewDidLoad() &#123;14 super.viewDidLoad()15 someFunc()16 someFunc()17 &#125;18 19 func someFunc()&#123;20 print(person)21 &#125;22&#125; 所以lazy可以简洁方便的修饰属性,适用情景: (1) 属性开始时还不确定是什么或者是否会被用到.(2) 属性需要复杂的计算:会消耗大量的CPU.(3) 属性只需要初始化一次时. 需要注意的是:(1) 被lazy修饰的属性(如这里的person)要用var来声明,因为该属性在类(如这里的ViewController)的实例初始化完成前还不能拥有一个值,而且访问该属性是一个mutating操作,所以包含该属性的struct或class也应该是可被修改的.而用let修饰的全局常量或者类属性(type property)却默认是lazy的(也是线程安全的). (2) 并发性问题:如官方文档中提示: If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once. 即在多线程操作中, 被lazy修饰的属性可能被多个线程访问,则只初始化一次就不能保证了.目测替代方案有二:可以放在dispatch_once中初始化,或者像&lt; Lazy Properties in Structs &gt;那样在属性创建前根据判断是否已存在而作不同的操作. 1import UIKit23class Person &#123;4&#125;56var name:String?78class ViewController: UIViewController &#123;9 10 lazy var person:Person &#x3D; &#123;11 var tmpPerson &#x3D; Person()12 print(&quot;此处有耗性能操作&quot;)13 return tmpPerson14 &#125;()1516 override func viewDidLoad() &#123;17 super.viewDidLoad()18 19 for _ in 1...3&#123;20 dispatch_async(dispatch_queue_create(&quot;com.yg&quot;, DISPATCH_QUEUE_CONCURRENT), &#123;21 self.someFunc()22 &#125;)23 &#125;24 &#125;25 26 func someFunc()&#123;27 print(person)28 &#125;29&#125;30&#x2F;&#x2F;此处有耗性能操作31&#x2F;&#x2F;此处有耗性能操作32&#x2F;&#x2F;此处有耗性能操作33&#x2F;&#x2F;LazyTest.Person34&#x2F;&#x2F;LazyTest.Person35&#x2F;&#x2F;LazyTest.Person 3. lazy的其他用法:在对集合类型(如Array)使用高阶函数(如map)时,所有的结果会在第一次访问前就计算出来,即使我们只访问其中的一个元素: 1class ViewController: UIViewController &#123;2 override func viewDidLoad() &#123;3 super.viewDidLoad()4 5 let array &#x3D; Array(0..&lt;100)6 7 let result &#x3D; array.map&#123;8 (i: Int) -&gt; Int in9 print(&quot;访问前的准备: \\(i)&quot;)10 return i * 211 &#125;12 print(&quot;准备访问数组最后一个元素&quot;)13 print(&quot;最后一个元素是: \\(result[99])&quot;)14 print(&quot;访问完毕&quot;)1516 &#125;17&#125;18&#x2F;&#x2F;...19&#x2F;&#x2F;访问前的准备: 9620&#x2F;&#x2F;访问前的准备: 9721&#x2F;&#x2F;访问前的准备: 9822&#x2F;&#x2F;访问前的准备: 9923&#x2F;&#x2F;准备访问数组最后一个元素24&#x2F;&#x2F;最后一个元素是: 19825&#x2F;&#x2F;访问完毕 这无疑不是我们想要的. 这时lazy就派上用场了!在这些集合类中有个名为 lazy 的属性，它包含的内容与所在的集合类对象一样，并且可以对 “map”,”filter” 等操作延迟实现。所以这样使用lazy可以大大优化性能： 1class ViewController: UIViewController &#123;2 override func viewDidLoad() &#123;3 super.viewDidLoad()4 5 let array &#x3D; Array(0..&lt;100)6 7 let result &#x3D; array.lazy.map&#123;8 (i: Int) -&gt; Int in9 print(&quot;访问前的准备: \\(i)&quot;)10 return i * 211 &#125;12 print(&quot;准备访问数组最后一个元素&quot;)13 print(&quot;最后一个元素是: \\(result[99])&quot;)14 print(&quot;访问完毕&quot;)1516 &#125;17&#125;18&#x2F;&#x2F;准备访问数组最后一个元素19&#x2F;&#x2F;访问前的准备: 9920&#x2F;&#x2F;最后一个元素是: 19821&#x2F;&#x2F;访问完毕 参考： LAZY 修饰符和 LAZY 方法 Lazy Initialization with Swift Lazy Properties in Structs The Swift Programming Language Being Lazy","categories":[],"tags":[{"name":"iOS 开发","slug":"iOS-开发","permalink":"http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"}]},{"title":"（转）iOS常用控件尺寸大集合","slug":"（转）iOS常用控件尺寸大集合","date":"2016-02-28T01:35:33.000Z","updated":"2016-05-19T20:41:00.000Z","comments":true,"path":"2016/02/28/（转）iOS常用控件尺寸大集合/","link":"","permalink":"http://yoursite.com/2016/02/28/%EF%BC%88%E8%BD%AC%EF%BC%89iOS%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E5%B0%BA%E5%AF%B8%E5%A4%A7%E9%9B%86%E5%90%88/","excerpt":"","text":"iPhone App Icon： iPad App Icon： iPhone、iPad通用App Icon： . . . 延伸阅读：Points VS. Pixels &gt; The iPhone 4 introduced a high resolution display with twice the pixels of previous iPhones. However you don’t have to modify your code to support high-res displays; the coordinate system goes by points rather than pixels, and the dimensions in points of the screen and all UI elements remain the same. iOS 4 supports high resolution displays (like the iPhone 4 display) via the scale property on UIScreen, UIView, UIImage, and CALayer classes. If the object is displaying high-res content, its scale property is set to 2.0. Otherwise it defaults to 1.0. &gt; All you need to do to support high-res displays is to provide @2x versions of the images in your project. See the checklist for updating to iOS4 or Apple documentation for Supporting High Resolution Screens for more info.","categories":[],"tags":[{"name":"iOS 开发","slug":"iOS-开发","permalink":"http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91/"}]}]}