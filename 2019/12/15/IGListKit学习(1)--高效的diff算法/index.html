<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>IGListKit 学习(1) 一种高效的 diff 算法 | Sunshine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文目录如图：   一、背景近来因为业务需要，学习下如何更好的展示Feed流，而 IGListKit 是 Instagram 用来重构 Feed 流的开源库，可以实现在Feed流灵活的展示各种类型的数据，其中用到的 diff 算法是用来对比两个不同的数组的，使得可以在设置新数组时，界面只对有变化的数据进行更新。这个算法能做到时间复杂度为线性增长，是比较高效的算法。下面分别介绍 IGListKit">
<meta name="keywords" content="iOS 开发">
<meta property="og:type" content="article">
<meta property="og:title" content="IGListKit 学习(1) 一种高效的 diff 算法">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;index.html">
<meta property="og:site_name" content="Sunshine">
<meta property="og:description" content="本文目录如图：   一、背景近来因为业务需要，学习下如何更好的展示Feed流，而 IGListKit 是 Instagram 用来重构 Feed 流的开源库，可以实现在Feed流灵活的展示各种类型的数据，其中用到的 diff 算法是用来对比两个不同的数组的，使得可以在设置新数组时，界面只对有变化的数据进行更新。这个算法能做到时间复杂度为线性增长，是比较高效的算法。下面分别介绍 IGListKit">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121500.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121501.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121502.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121503.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121504.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121505.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121506.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121507.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121508.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121509.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121510.png">
<meta property="og:updated_time" content="2019-12-14T19:36:13.572Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;15&#x2F;IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95&#x2F;19121500.png">
  
    <link rel="alternative" href="/atom.xml" title="Sunshine" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/logo6.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Gang Yang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Love life, as fanaticism as I love my yueqing.</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/SunshineYG888" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/2477038064?refer_flag=1001030101_&is_all=1" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Objective-C/" style="font-size: 10px;">Objective-C</a> <a href="/tags/iOS-%E5%BC%80%E5%8F%91/" style="font-size: 20px;">iOS 开发</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Gang Yang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/logo6.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Gang Yang</h1>
			</hgroup>
			
			<p class="header-subtitle">Love life, as fanaticism as I love my yueqing.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/SunshineYG888" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/2477038064?refer_flag=1001030101_&is_all=1" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-IGListKit学习(1)--高效的diff算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/" class="article-date">
  	<time datetime="2019-12-14T16:00:00.000Z" itemprop="datePublished">2019-12-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      IGListKit 学习(1) 一种高效的 diff 算法
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS-%E5%BC%80%E5%8F%91/" rel="tag">iOS 开发</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文目录如图：</p>
<img src="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/19121500.png" class="" title="img">

<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>近来因为业务需要，学习下如何更好的展示Feed流，而 IGListKit 是 Instagram 用来重构 Feed 流的开源库，可以实现在Feed流灵活的展示各种类型的数据，其中用到的 diff 算法是用来对比两个不同的数组的，使得可以在设置新数组时，界面只对有变化的数据进行更新。这个算法能做到时间复杂度为线性增长，是比较高效的算法。<br>下面分别介绍 <a href="https://dl.acm.org/citation.cfm?id=359467&dl=ACM&coll=DL" target="_blank" rel="noopener">IGListKit 参考的文献</a>中介绍的算法以及 IGListKit 是如何用 Objective-C 来实现这个算法的。</p>
<a id="more"></a>

<h1 id="二、文献中的算法"><a href="#二、文献中的算法" class="headerlink" title="二、文献中的算法"></a>二、文献中的算法</h1><p>我们称原文件(old file)为O，新文件(new file)为N。<br>把文件中每个基本单元当做一行(line)，可以是个字符，单词，句子，或者段落等<br>通过修改O可以得到N。<br>用到的数据结构有3个：一个符号表(symbol table)和两个数组(OA, NA)。</p>
<p>对于符号表，以每行L的文本(text)作为key，value则为一个entry，一个entry包含三个数据：</p>
<ul>
<li>OC(old counter)，表示L在文件O中出现的次数；</li>
<li>NC(new counter)，表示L在文件N中出现的次数；</li>
<li>OLNO，表示L在文件O中出现的位置，只有当OC=1时才有用。</li>
</ul>
<img src="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/19121501.png" class="" title="img">
<p><em>图1. 符号表的结构</em></p>
<p>O(N)文件中的每行L都有一个entry，这个entry会存储到数组OA(NA)中。<br>每个entry要么持有指向符号表的L对应的entry，要么记录了L在文件N(O)中的位置。(and a bit to specify which?)</p>
<p>这个算法有6个pass：<br>1、遍历文件N的每个line i<br>    - 使得每个line i在符号表都有对应的entry；<br>    - entry中的NC为line i的出现次数；<br>    - 把指向这个entry的指针存储到NA[i]中。</p>
<img src="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/19121502.png" class="" title="img">
<p><em>图2. 经过步骤1之后，符号表和NA的结果</em></p>
<p>2、和1类似，遍历文件O的每个line j<br>    - 使得每个line j在符号表都有对应的entry；<br>    - entry中的OC为line j的出现次数；<br>    - entry中的OLNO为line j在文件O中的行号；<br>    - 把指向这个entry的指针存储到OA[j]中。</p>
<img src="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/19121503.png" class="" title="img">
<p><em>图3. 经过步骤2之后，符号表和OA的结果，注意如果某line在O、N都出现了，位置分别为j、i，则OA[j]、NA[i]指向同一个entry</em></p>
<p>3、找出符号表中满足“OC=NC=1”的entry（比如上图中的entry，对应N中的Line i、O中的Line j），这表示该line在文件修改前后没有变化，则把NA[i]、OA[j]分别改为该line在另一个文件O、N中的行号，即：<br>NA[i] = j<br>OA[j] = i</p>
<img src="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/19121504.png" class="" title="img">
<p><em>图4. 对于修改前后没变化的line</em></p>
<p>4、对于步骤3中找出的 NA[i] 与 OA[j] 对应（即 NA[i] = j 且 OA[j] = i）， 如果NA[i+1]、OA[j+1]也指向同一个entry，则说明该line在文件修改前后也没有变化，则使：<br>NA[i+1] = j+1<br>OA[j+1] = i+1</p>
<p>5、类似步骤4，检查NA[i-1]、OA[j-1]，如果都指向同一个entry，则：<br>NA[i-1] = j-1<br>OA[j-1] = i-1</p>
<p>（这里没理解，在步骤3找到的line没包含步骤4、5中的line么？）</p>
<p>6、输出结果：<br>    - 如果NA[i]指向一个符号表的entry，说明新文件的对应的 line i 是新增的（如图5中NA的10、9）；<br>    - 如果 NA[i] 与 OA[j] 对应（即 NA[i] = j 且 OA[j] = i），但 NA[i+1] 与 OA[j+1] 不对应（即 NA[i+1] 要么指向一个符号表的entry，要么是不等于j的另一个数字），则说明 line i 处于删除或者移动范围的边界（如图5中NA的8）</p>
<img src="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/19121505.png" class="" title="img">
<p><em>图5. 新旧文件的对应的两数组(NA, OA)的对比，根据原文的图1简化所得</em><br>（这里没理解，NA中的2、6也应该是移动范围的边界？）</p>
<h1 id="三、IGListKit-中-diffable-算法的实现"><a href="#三、IGListKit-中-diffable-算法的实现" class="headerlink" title="三、IGListKit  中 diffable 算法的实现"></a>三、IGListKit  中 diffable 算法的实现</h1><p>算法实现是在 <a href="https://github.com/Instagram/IGListKit/blob/e4c60650f2953eb1adb258306ad5974b8e812eb3/Source/IGListDiffKit/IGListDiff.mm" target="_blank" rel="noopener">IGListDiff.mm</a> 中IGListDiffing函数中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">static id IGListDiffing(BOOL returnIndexPaths,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">                        NSInteger fromSection,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">                        NSInteger toSection,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                        NSArray&lt;id&lt;IGListDiffable&gt;&gt; *oldArray,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                        NSArray&lt;id&lt;IGListDiffable&gt;&gt; *newArray,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                        IGListDiffOption option,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                        IGListExperiment experiments)</span></pre></td></tr></table></figure>
<p>作用是：传入新旧两个数组（oldArray、newArray），用算法进行对比，得到具体差异（分别有哪些元素进行了插入(insert)、删除(delete)、移动(move)、更新(move)操作）。<br>其中更新操作是上面文献的算法没有提到的，因为文献中只对比文案，文案不同则代表不同的元素。</p>
<p>IGListDiffing 先处理两种简单的情况：</p>
<ul>
<li>新数组为空，则说明旧数组的所有元素都进行了删除操作；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; if no new objects, everything from the oldArray is deleted</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; take a shortcut and just build a delete-everything result</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    if (newCount &#x3D;&#x3D; 0) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        if (returnIndexPaths) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            return [[IGListIndexPathResult alloc] initWithInserts:[NSArray new]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                                                          deletes:indexPathsAndPopulateMap(oldArray, fromSection, oldMap)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                                                          updates:[NSArray new]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                                                            moves:[NSArray new]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                                                  oldIndexPathMap:oldMap</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                                                  newIndexPathMap:newMap];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure></li>
<li>旧数组为空，则说明新数组的所有元素都进行了插入操作；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; if no old objects, everything from the newArray is inserted</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; take a shortcut and just build an insert-everything result</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    if (oldCount &#x3D;&#x3D; 0) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        if (returnIndexPaths) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            return [[IGListIndexPathResult alloc] initWithInserts:indexPathsAndPopulateMap(newArray, toSection, newMap)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                                                          deletes:[NSArray new]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                                                          updates:[NSArray new]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                                                            moves:[NSArray new]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                                                  oldIndexPathMap:oldMap</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                                                  newIndexPathMap:newMap];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
接着是在新旧数组都不为空时的对比：<br>假设数组的每个元素包含两个值：</li>
</ul>
<img src="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/19121506.png" class="" title="img">
<p><em>图6. 本文例子中的数组元素的结构</em></p>
<p>其中key对应的值用作符号表中的key，text对应的值用作判断数据是否相等。<br>现在假设新旧数组分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">oldArray : (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &quot;key:1, text:UnchangedObj&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &quot;key:2, text:DeletedObj&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &quot;key:3, text:MovedObj1&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &quot;key:4, text:MovedObj2&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &quot;key:5, text:UpdateObjOld&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &quot;key:6, text:SameObj&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">newArray : (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &quot;key:1, text:UnchangedObj&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &quot;key:7, text:InsertedObj&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &quot;key:5, text:UpdateObjNew&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &quot;key:6, text:SameObj&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &quot;key:6, text:SameObj&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &quot;key:3, text:MovedObj1&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &quot;key:4, text:MovedObj2&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>

<p>然后对比过程为：<br>1、先定义一个unordered_map类型的 table 作为文章中的符号表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; symbol table uses the old&#x2F;new array diffIdentifier as the key and IGListEntry as the value</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; using id&lt;NSObject&gt; as the key provided by https:&#x2F;&#x2F;lists.gnu.org&#x2F;archive&#x2F;html&#x2F;discuss-gnustep&#x2F;2011-07&#x2F;msg00019.html</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    unordered_map&lt;id&lt;NSObject&gt;, IGListEntry, IGListHashID, IGListEqualID&gt; table;</span></pre></td></tr></table></figure>
<p>新旧数组都用这个 table 来存储对应的 entry，entry的结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 用来追踪对比过程中的数据状态.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">struct IGListEntry &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;&#x2F; 数据在旧数组出现的次数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    NSInteger oldCounter &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;&#x2F; 数据在新数组出现的次数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    NSInteger newCounter &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;&#x2F; 数据在新数组出现的索引</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    stack&lt;NSInteger&gt; oldIndexes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;&#x2F; 通过isEqual:对比对应的数据，判断数据是否有更新</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    BOOL updated &#x3D; NO;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>2、进行第一个pass（对应文献中的第一个pass），遍历新数组newArray，记录每个元素的出现情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; pass 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 为新数组的每个元素创建一个entry</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    vector&lt;IGListRecord&gt; newResultsArray(newCount);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    for (NSInteger i &#x3D; 0; i &lt; newCount; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        id&lt;NSObject&gt; key &#x3D; IGListTableKey(newArray[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        IGListEntry &amp;entry &#x3D; table[key];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F; 每出现一次，就将newCounter属性加1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        entry.newCounter++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 往entry的oldIndexes栈push一个NSNotFound</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        entry.oldIndexes.push(NSNotFound);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 让newResultsArray数组元素的entry变量指向table的一个entry</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        newResultsArray[i].entry &#x3D; &amp;entry;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<p>newResultsArray 对应上文中的NA，其中的每一个元素类型是IGListRecord：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 追踪entry和索引。索引默认为NSNotFound</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">struct IGListRecord &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    IGListEntry *entry;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    mutable NSInteger index;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    IGListRecord() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        entry &#x3D; NULL;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        index &#x3D; NSNotFound;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>因为上文的NA中的元素NA[i]可以指向一个entry，也可以存储另一个文件的对应数据的行号，这两个值在这里分别用entry、index来表示</p>
<p>在这个例子中，第一个pass结束后的结果如图7：</p>
<img src="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/19121507.png" class="" title="img">
<p><em>图7. 红色部分是在第一个pass中，对符号表中的entry的修改。NF是NSNotFound的缩写。</em></p>
<p>3、进行第二个pass（对应文献中的第二个pass），遍历旧数组oldArray，记录每个元素的出现情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; pass 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 为新数组的每个元素创建一个entry（如果符号表里没有对的entry的话）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    vector&lt;IGListRecord&gt; oldResultsArray(oldCount);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    for (NSInteger i &#x3D; oldCount - 1; i &gt;&#x3D; 0; i--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        id&lt;NSObject&gt; key &#x3D; IGListTableKey(oldArray[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        IGListEntry &amp;entry &#x3D; table[key];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F; 每出现一次，就将newCounter属性加1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        entry.oldCounter++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 往entry的oldIndexes栈push i, 存储在旧数组的位置</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        entry.oldIndexes.push(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 让oldResultsArray数组元素的entry变量指向table的一个entry</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        oldResultsArray[i].entry &#x3D; &amp;entry;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>在这个例子中，第二个pass结束后的结果如图8：</p>
<img src="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/19121508.png" class="" title="img">
<p><em>图8. 红色部分是在第二个pass中，对符号表中的entry的修改。和第一个pass得到的结果相比，除了最后一个entry是新增的（对应旧数组中被delete的元素），其他entry都是用已有的。</em></p>
<p>4、进行第三个pass（对应文献中的第三个pass），处理在新旧数组都出现的元素，这里做了两件事：<br>（1）对比这两个元素是否相等，不等的话把对应的entry的updated设置为YES;<br>（2）类似文献中的把NA[i] 与 OA[j] 对应起来（即 NA[i] = j 且 OA[j] = i），这里是把该元素在新旧数组的位置分别存储到oldResultsArray、newResultsArray对应的元素的index中。</p>
<p>代码实现为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; pass 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 遍历新数组，处理在新旧数组都出现的元素</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    for (NSInteger i &#x3D; 0; i &lt; newCount; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取newResultsArray中对应的元素的entry</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        IGListEntry *entry &#x3D; newResultsArray[i].entry;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 取该entry的oldIndexes的栈顶数字，如果是新插入的，则该数字为NSNotFound</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        NSCAssert(!entry-&gt;oldIndexes.empty(), @&quot;Old indexes is empty while iterating new item %li. Should have NSNotFound&quot;, (long)i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        const NSInteger originalIndex &#x3D; entry-&gt;oldIndexes.top();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 用了该entry的oldIndexes的栈顶数字，将其出栈</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        entry-&gt;oldIndexes.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 如果originalIndex不为NSNotFound，说明和该entry对应的元素在旧数组也出现，则这个元素是在新旧数组都出现的元素</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 对比这两个元素是否相等，不等的话把对应的entry的updated设置为YES;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 对比策略有两种，一是直接对比地址，二是让数组的元素实现 IGListDiffable 协议的 -isEqualToDiffableObject :方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        if (originalIndex &lt; oldCount) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            const id&lt;IGListDiffable&gt; n &#x3D; newArray[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            const id&lt;IGListDiffable&gt; o &#x3D; oldArray[originalIndex];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            switch (option) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                case IGListDiffPointerPersonality:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                    &#x2F;&#x2F; 这里是直接对比新旧元素</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                    if (n !&#x3D; o) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                        entry-&gt;updated &#x3D; YES;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                    break;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                case IGListDiffEquality:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                    &#x2F;&#x2F; 如果新旧两个元素地址不同，则用 -[IGListDiffable isEqualToDiffableObject:] 方法进行对比</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                    if (n !&#x3D; o &amp;&amp; ![n isEqualToDiffableObject:o]) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                        entry-&gt;updated &#x3D; YES;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                    break;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 对于新旧数组都出现的元素，类似文献中的把NA[i] 与 OA[j] 对应起来（即 NA[i] &#x3D; j 且 OA[j] &#x3D; i）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        if (originalIndex !&#x3D; NSNotFound</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            &amp;&amp; entry-&gt;newCounter &gt; 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">            &amp;&amp; entry-&gt;oldCounter &gt; 0) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            newResultsArray[i].index &#x3D; originalIndex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            oldResultsArray[originalIndex].index &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>从代码可以看到，为什么是遍历新数组而不是遍历旧数组呢？因为entry中的oldIndexes存储的就是该entry对应的元素在旧数组的位置，这样就可以在遍历新数组的时候，也能获取旧数组中对应的元素了。</p>
<p>在这个例子中，第三个pass结束后的结果如图9：</p>
<img src="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/19121509.png" class="" title="img">
<p><em>图9. 红色部分是在第三个pass中新增的修改。</em></p>
<p>此时可以看到：<br>1）对于在新旧数组（newArray、oldArray）都出现的元素，在newResultArray、oldResultArray中对应的元素的index变量都分别记录了oldArray、newArray中的位置；<br>2）对于在新旧数组（newArray、oldArray）都出现的元素，如果两者的key相同、text不同，则对应的entry的updated为YES，表示该元素有更新操作；<br>3）对于只在新（newArray）都出现的元素，在这个pass中只是把对应的entry的oldIndexes栈的栈顶数字pop了出来；<br>4）对于只在旧（oldArray）都出现的元素，在这个pass中没有修改对应的entry。</p>
<p>5、分析结果</p>
<p>就是将前面得到结果，转化为具体的diff信息（insert、delete、move、update）。<br>（1）遍历oldResultArray数组，如果某个元素的index为NSNotFound，则说明它没出现在新数组中，也就是被删除了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    for (NSInteger i &#x3D; 0; i &lt; oldCount; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 记录当前位置之前有多少元素被删除了的，后面计算move数组会用到</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        deleteOffsets[i] &#x3D; runningOffset;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        const IGListRecord record &#x3D; oldResultsArray[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        if (record.index &#x3D;&#x3D; NSNotFound) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                &#x2F;&#x2F; 把在旧数组的位置添加到delete数组里</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            addIndexToCollection(returnIndexPaths, mDeletes, fromSection, i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            runningOffset++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        addIndexToMap(returnIndexPaths, fromSection, i, oldArray[i], oldMap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>（2）遍历newResultArray数组，可以找到增加、移动、更新了的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">    for (NSInteger i &#x3D; 0; i &lt; newCount; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        insertOffsets[i] &#x3D; runningOffset;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        const IGListRecord record &#x3D; newResultsArray[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        const NSInteger oldIndex &#x3D; record.index;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 如果index为NSNotFound，说明该元素是新增的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        if (record.index &#x3D;&#x3D; NSNotFound) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                &#x2F;&#x2F; 把在新数组的位置添加到insert数组里</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            addIndexToCollection(returnIndexPaths, mInserts, toSection, i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                &#x2F;&#x2F; 记录新增的元素的数字加1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            runningOffset++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F; 走到这里，说明index不为NSNotFound，则该元素是在新旧数组都出现的元素，有三种可能：不变，移动了位置，更新了值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F; 如果updated为YES，说明该元素有更新其值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            if (record.entry-&gt;updated) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                    &#x2F;&#x2F; 把在旧数组的位置添加到update数组里</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                addIndexToCollection(returnIndexPaths, mUpdates, fromSection, oldIndex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F; 如果除去该位置之前的insert、delete了的元素的影响，在新旧数组位置不一样的话，则说明位置有所移动</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            const NSInteger insertOffset &#x3D; insertOffsets[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            const NSInteger deleteOffset &#x3D; deleteOffsets[oldIndex];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            if ((oldIndex - deleteOffset + insertOffset) !&#x3D; i) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                id move;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                if (returnIndexPaths) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                    NSIndexPath *from &#x3D; [NSIndexPath indexPathForItem:oldIndex inSection:fromSection];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                    NSIndexPath *to &#x3D; [NSIndexPath indexPathForItem:i inSection:toSection];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                    move &#x3D; [[IGListMoveIndexPath alloc] initWithFrom:from to:to];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                    move &#x3D; [[IGListMoveIndex alloc] initWithFrom:oldIndex to:i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">                &#x2F;&#x2F; 把记录了移动的前后位置的信息添加到move数组里</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                [mMoves addObject:move];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        addIndexToMap(returnIndexPaths, toSection, i, newArray[i], newMap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>在这个例子中，最后得到的结果是：</p>
<table>
<thead>
<tr>
<th align="center">变化类型</th>
<th align="center">位置数组</th>
<th align="center">记录的位置在哪个数组</th>
</tr>
</thead>
<tbody><tr>
<td align="center">insert</td>
<td align="center">[1, 4]</td>
<td align="center">新数组</td>
</tr>
<tr>
<td align="center">delete</td>
<td align="center">[1]</td>
<td align="center">旧数组</td>
</tr>
<tr>
<td align="center">update</td>
<td align="center">[4]</td>
<td align="center">旧数组</td>
</tr>
<tr>
<td align="center">move</td>
<td align="center">[(from: 4, to: 2), (from: 5, to: 3)，(from: 2, to: 5), (from: 3, to: 6)]</td>
<td align="center">from是旧数组，to 是新数组</td>
</tr>
</tbody></table>
<p>也可以表示为图10：</p>
<img src="/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/19121510.png" class="" title="img">
<p><em>图10. 本文例子中新旧两个数组对比得到的具体差异</em></p>
<h1 id="四、讨论"><a href="#四、讨论" class="headerlink" title="四、讨论"></a>四、讨论</h1><p>1、文献的算法和 IGListKit  实现的算法对比<br>前者会关注move的范围，后者没有；<br>后者会关注元素是否有update操作，前者没有（因为对比的只是文本）。<br>2、时间复杂度<br>平均情况都是O(m+n)。<br>3、空间复杂度<br>平均情况都是O(m+n)。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>IGListKit<br><a href="https://instagram.github.io/IGListKit/" target="_blank" rel="noopener">https://instagram.github.io/IGListKit/</a></p>
<p>A technique for isolating differences between files<br><a href="https://dl.acm.org/citation.cfm?id=359467&amp;dl=ACM&amp;coll=DL" target="_blank" rel="noopener">https://dl.acm.org/citation.cfm?id=359467&amp;dl=ACM&amp;coll=DL</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/05/24/Objective-C-Runtime/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Objective-C Runtime</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="IGListKit学习(1)--高效的diff算法" data-title="IGListKit 学习(1) 一种高效的 diff 算法" data-url="http://yoursite.com/2019/12/15/IGListKit%E5%AD%A6%E4%B9%A0(1)--%E9%AB%98%E6%95%88%E7%9A%84diff%E7%AE%97%E6%B3%95/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 Gang Yang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>